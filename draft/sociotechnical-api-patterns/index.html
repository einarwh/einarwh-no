<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><link rel="icon" sizes="any" type="image/svg+xml" href="/images/3d4226764423/favfish.svg"><title>Socio-technical API patterns | einarwh</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta property="og:title" content="Socio-technical API patterns"><meta property="og:url" content="https://einarwh.no/draft/sociotechnical-api-patterns/"><link rel="stylesheet" href="/bundles/460d8eeb81b7/app.css"></head><body><header><a href="/">einarwh</a><hr></header><h1>Socio-technical API patterns</h1>
<p class="blog-post-date">April 22, 2025</p>
<p><img src="/svg/2ac3de372dbe/byteman-pattern-long.svg" alt="A pattern of stick people."></p>
<p>An API is a way to connect two or more systems together. What kinds of systems? Software systems, of course. What a silly question! It is Application Programming Interface after all. It is an interface between applications. Right?</p>
<p>Yes. But there are more questions we could ask. Why should these systems be connected? Who wants the systems to connect? What are they trying to accomplish? What constraints do they operate under? Who designs the interface? Who will be responsible for the evolution of both the systems and the interface that connects them as time passes? All of these questions point toward the existence of people. The reason is, of course, that software systems come with people attached. When we connect software systems, we also connect socio-technical systems. Leaving this out when discussing APIs causes us to miss a lot of things.</p>
<p>By asking questions like these, we start laying out the socio-technical landscape of APIs. The answers to those questions in a particular context places a given API (and the people involved in it either as providers or consumers) in that landscape. My experience suggests that socio-technical forces tend to pull APIs towards certain points in that landscape. In other words, there are recurring socio-technical API patterns.</p>
<p>Noticing and labeling such patterns may help us better understand and fix potential problems. For instance, we may discover that we’ve fallen into a known anti-pattern. This is valuable in at least two ways. First, articulating our pain and understanding what contributes to it is useful in itself. Second, it might provide us with strategies to move towards better, healthier patterns.</p>
<p>The purpose of this blog post is to articulate some questions that help lay out the socio-technical landscape for APIs, identify some typical answers, and describe a few patterns I have observed in my career. Those patterns are <a href="#millstone">The Millstone</a>, <a href="#mountain">The Mountain</a>, <a href="#rapids">The Rapids</a> and <a href="#sock-puppet">The Sock Puppet</a>. I hope you will find them useful.</p>
<p>But first, a look at the socio-technical landscape and the forces that give rise to these patterns.</p>
<h3>Consumer-provider relationship</h3>
<p>It seems natural to start with the people on the two sides of the API divide, the provider and the consumer(s) of the API. Some broad, overarching questions might be: What are their goals? What are their responsibilities? What are their constraints? And as a follow-up: How important is the API to them?</p>
<p>For the API provider, the answer to the last question can range from main focus (the team exists primarily to provide the API) to nuisance (the team has been instructed to provide an API to other team), with the middle ground being something like a side hustle. This is typically mirrored by the amount of resources available both for the initial development of the API and for its subsequent upkeep and evolution. For the API consumer, it can range from essential to optional.</p>
<p>The consumer and the provider are not necessarily aligned with respect to how important the API is to them. All combinations of attitudes are possible. A particularly interesting one is the case where the API is essential to the consumer but a nuisance to the provider. This is quite common for internal APIs.</p>
<p>Communication.</p>
<p>The relationship between the consumer and the provider of the API will</p>
<p>Also: time. Access to communication during initial design/development vs access to communication after the API is in production and largely settled.</p>
<p>Degree of communication? Communication channels? Ranging from practically no communication outside perhaps the ability to report bugs in a fire-and-forget manner to being able to walk over to someone’s desk and have a face-to-face conversation. (Of course being <em>able to</em> have a face-to-face conversation is not the same as using that ability, since people are subject to various kinds of inhibitions and self-defense mechanisms that may interfere, leading us to prefer lower-bandwidth but less-exposed asynchronous communication channels). Poor communication leads to workarounds, dependecies on assumptions, perceived invariants, undocumented features. This in turn makes it hard to change the API since the implementation becomes the interface. An example might be consumers exploiting apparent structure in strings to scavenge for data such as IDs. Having (Hyrum’s Law?)</p>
<p>Power dynamics.</p>
<p>Distinction between internal APIs and public APIs.</p>
<ul>
<li>
<p>Points of contention:</p>
<ul>
<li>Downtime</li>
<li>Errors</li>
<li>Evolution/Change</li>
<li>Stability/change rate</li>
</ul>
</li>
</ul>
<h3>API design</h3>
<p>But I’m getting ahead of myself. We can’t address all those questions at once. For now, let’s focus on how the API comes about, that is, how is it designed, and by whom? We can distinguish between unilateral and bilateral (or multilateral) design efforts. A unilateral or one-sided design effort means that the API provider - the party that will implement the API - does the all the work alone. In fact there might not be much of a distinction between designing the API and implementing it. The design is whatever was implemented. By contrast, a bilateral (or multilateral) design effort means that one or more API consumers is involved in the design. In that case, the design process is a collaboration and involves negotiation.</p>
<p>A number of prerequisites must be in place for a bilateral design process to be an option. In particular, the provider and the consumer(s) must be able to and want to collaborate. This requires a basic level of alignment and trust. Bilateral design is mostly feasible for internal APIs, where the API provider and the API consumer are two teams inside the same organization.</p>
<p>A bilateral design process can be more or less efficient and functional. To some extent, we can talk of gradients from unilateral to bilateral. To be “proper” bilateral, it is not enough for the API provider to check in with the API consumer often or solicit feedback during the design or implementation of the API. The design work must be a joint effort, with provider and consumer working together to determine the design of the API. This does not necessarily mean that the implementation of the API is a joint effort, just like the implementation of the client code that uses the API doesn’t have to be a joint effort. It can be, and it might be useful if it would be, but it doesn’t have to be.</p>
<p>In practical terms, the API provider and the API consumer just need to collaborate on the design of the interface itself. For Web APIs, it means producing an OpenAPI document together. The astute backend developer will note with terror that this means that the OpenAPI document can’t be reverse engineered from the API implementation using a tool like Swashbuckle if you want to do bilateral design. It is simply too cumbersome. You need much faster iteration cycles. Hence the OpenAPI document must be co-authored by hand, for instance in a mob design session involving at least one member from each team. An upside is that it is much easier to create high-quality OpenAPI documents by hand than it is to reverse engineer them.</p>
<p>A bilateral design process radically changes the interpretation and role of the OpenAPI document itself. In a unilateral API design, the OpenAPI document is <em>documentation</em>, that is, a description of how the API implementation works. Often the document will be coupled to the actual implementation through a reverse engineering process, ensuring that the documentation is always up to date. By contrast, in a bilateral API design, the OpenAPI document is better thought of as a specification or a contract: it is a description of what the provider and consumer(s) have agreed upon. Importantly, it is the contract that is the source of truth, not the behavior of the API. If there is a discrepancy between the contract and the behavior, it is a bug in the implementation of the API.</p>
<p>We want different things from documentation and contracts. Documentation should be accurate and up to date. Contracts should be reliable and stable. If the API provider pushes a change to the API implementation, we don’t want the contract to shift inadvertently. This is not how contracts work. Changing the contract is a serious matter. If my tenant starts paying me less for the appartment they’re renting, I don’t want the contract we signed to automatically change to reflect the new, lower rent. It’s not what we agreed upon. A contract is not the same as the description of behavior. A contract is, and must be, decoupled from behavior. This is a strength, not a weakness, with contracts.</p>
<h2>Service level</h2>
<p>A contract in broader terms should also cover the operation of the API.</p>
<ul>
<li>
<p>Points of contention:</p>
<ul>
<li>Downtime</li>
<li>Errors</li>
<li>Change</li>
<li>API stability/change rate</li>
</ul>
</li>
</ul>
<p>The so-called non-functional properties of an API are surprisingly often unknown. They are both undocumented and unspecified. This is particularly true for internal APIs. This is regrettable, since non-functional requirements are business requirements. For APIs-as-products, some non-functional properties may be specified in a service-level agreement.</p>
<h3>Consumer-provider relationship</h3>
<ul>
<li>Provider:
<ul>
<li>How is work on the API financed?</li>
<li>How much time and effort does it require?
<ul>
<li>Initial development cost</li>
<li>Maintenance, evolution, operations</li>
</ul>
</li>
</ul>
</li>
<li>Consumers:
<ul>
<li>Motivation to evolve client code.</li>
</ul>
</li>
<li>Power dynamics
<ul>
<li>The consumer’s ability to influence/ignore the actions of the provider</li>
<li>The provider’s ability to influence/ignore the actions of the consumer</li>
</ul>
</li>
<li>How is change handled?</li>
<li>Poor communication leads to workarounds, depending on assumptions, perceived invariants, undocumented features.</li>
<li>No SLA</li>
<li>“Best effort” aka “It is what it is”</li>
<li>Determined by consciousness, availability of resources of the providers.</li>
<li>Determined by the clout and leverage of the consumer(s).</li>
<li>Very often unspecified.</li>
<li>Often even unarticulated/unacknowledged.</li>
<li>Range in ambition:
<ul>
<li>API as product</li>
<li>Data exposure</li>
</ul>
</li>
</ul>
<p>Agenda</p>
<ul>
<li>What is an API?</li>
<li>Technical perspective</li>
<li>Socio-technical perspective</li>
<li>Patterns</li>
<li>Socio-technical checklist</li>
</ul>
<p>What is an API?</p>
<ul>
<li>Connecting two or more systems</li>
<li>What kinds of systems?</li>
</ul>
<p>Technical perspective</p>
<ul>
<li>Connecting two technical systems</li>
<li>Why are these systems being connected? (Access to data, something-as-a-service)</li>
<li>Typical case: Web API, JSON over HTTP.</li>
<li>How is the API designed? (Unilaterally, bilaterally, collaboration? negotiation?)</li>
<li>Is there a spesification? (E.g. OpenAPI)</li>
<li>Documentation (unilateral) vs contract (bilateral)</li>
<li>Non-functional requirements typically undefined</li>
<li>Non-functional properties typically unknown</li>
<li>This can be a problem :-)</li>
<li>Points towards SLAs, which shifts our perspective.</li>
</ul>
<p>Socio-technical perspective</p>
<ul>
<li>Who are connecting these systems?</li>
<li>How are the systems connected? Who does the connecting?</li>
<li>Connecting two socio-technical systems</li>
<li>Who are the consumers and who are the providers?</li>
<li>What are their constraints and their goals?</li>
<li>Points of contention:
<ul>
<li>Downtime</li>
<li>Errors</li>
<li>Change</li>
<li>API stability/change rate</li>
</ul>
</li>
<li>Responsibilities of consumers</li>
<li>Responsibilities of providers</li>
<li>Provider:
<ul>
<li>How is work on the API financed?</li>
<li>How much time and effort does it require?
<ul>
<li>Initial development cost</li>
<li>Maintenance, evolution, operations</li>
</ul>
</li>
</ul>
</li>
<li>Consumers:
<ul>
<li>Motivation to evolve client code.</li>
</ul>
</li>
<li>Power dynamics
<ul>
<li>The consumer’s ability to influence/ignore the actions of the provider</li>
<li>The provider’s ability to influence/ignore the actions of the consumer</li>
</ul>
</li>
<li>How is change handled?</li>
<li>Poor communication leads to workarounds, depending on assumptions, perceived invariants, undocumented features.</li>
<li>How important is the API for the consuming system? (Optional, required)</li>
<li>No SLA</li>
<li>“Best effort” aka “It is what it is”</li>
<li>Determined by consciousness, availability of resources of the providers.</li>
<li>Determined by the clout and leverage of the consumer(s).</li>
<li>Very often unspecified.</li>
<li>Often even unarticulated/unacknowledged.</li>
<li>Range in ambition:
<ul>
<li>API as product</li>
<li>Data exposure</li>
</ul>
</li>
</ul>
<p>Patterns</p>
<ul>
<li>The millstone</li>
<li>The mountain</li>
<li>The rapids (with or without beaver dams)</li>
<li>The sockpuppets</li>
<li>Crowd-sourcing: challenge you to identify other patterns, e.g. by identifying a dominant socio-technical factor</li>
</ul>
<p>Socio-technical checklist</p>
<ul>
<li>Improve visibility</li>
<li>Articulate the unarticulated</li>
<li>Silently undefined -&gt; either explicitly defined or explicitly undefined</li>
<li>Checklist
<ul>
<li>Who is the consumer and who is the provider?</li>
<li>What constraints do they operate under?</li>
<li>What are the power dynamics between consumer and provider?</li>
<li>What is the collaboration like?</li>
<li>What are the communication channels?</li>
<li>How important is the API to each party?</li>
<li>What is the expected change rate for the API?</li>
<li>What is the SLA?</li>
<li>Are both sides happy?</li>
</ul>
</li>
</ul>
<h2>Patterns</h2>
<p>Text.</p>
<h3 id="millstone">The Millstone</h3>
<!-- ### <a name="millstone">The Millstone</a> -->
<p>The Millstone is a common anti-pattern for internal APIs. It comes about when a software team is instructed by some actor with the necessary clout in the organization to provide an API for another team. Providing this API is not the main focus for the team, but they are required to do so anyway. The API is a nuisance to them. They must carve out time of their busy schedule to provide the API. There is no budget for either initial design or upkeep of the API, so they are inclined to do the minimal effort to fulfil their end of the bargain. This typically means “exposing some data” over HTTP. There is no time or inclination to do any proper design or product development.</p>
<p>Exposing data is by definition a matter of turning internal data into public data. The unfortunate consequence is that the API provider has now effectively poured concrete over their internal data model, and their life is much harder. The API provider will typically want to change the API over time to enable them/reflect the evolution of their data model. However, they will need to synchronize this with the API consumer(s) who may have little incentive to change. Their ability to coerce the consumers to update is a matter of organizational power dynamics. The API is like a millstone around their necks, hence the name of the pattern.</p>
<p>The problems with the Millstone pattern are much more pronounced for the provider than for the consumers. However the situation isn’t necessarily great for consumers either. The API tends to be poorly specified. There is no stable contract, just reverse engineered documentation. The API may be subject to inadvertent changes. There is no SLA, just the “best effort” of a team that would rather spend their time on something else. Best may fall quite a bit short of good. An upside is that the consumer team at least tends to have easy access to the provider team.</p>
<p>How do you avoid falling into the Millstone pattern? The forces pulling toward the pattern are strong, and so must be tackled head-on. It poses a number of challenges. First, the organization needs to be aware of the dangers of the Millstone pattern. Decision makers need to be mature enough to realize that providing an API is not a one-time cost, it is a long-time commitment.Initial investments in API quality pay off, whereas sloppy initial work can exact a cost for the lifetime of the API.</p>
<p>The API must be treated as a proper product. This includes observability. The API enters the portfolio of products that the team needs to support, whether the team wants it to or not. The only variables are the quality of the API and how much unacknowledged ghost work the provider team will need to do. It is important that the team’s environment and stakeholders understand this. The team will need to allocate some of its time and focus on the API, which means less time and focus on other products.</p>
<p>The provider and the consumer should collaborate on bilateral API design, to create a design that better serves consumer needs. There should be explicit agreements on anything that will otherwise be left to power dynamics. Tacit assumptions about uptimes and support must be made explicit. There should be a reciprocal service level agreement that outlines commitments of both provider and consumer. The teams should agree on a versioning strategy and a change cadence. A mechanism for deprecation must be built in.</p>
<h3 id="mountain">The Mountain (and the Volcano)</h3>
<!-- ### <a name="mountain">The Mountain (and the Volcano)</a> -->
<p>The Mountain is a common pattern where the API provider is a big tech company. The name of the pattern comes from the saying “if the Mountain won’t go to Mohammed, then Mohammed must come to the Mountain”.</p>
<p>In terms of time, the API already exists when the consumer makes the decision about whether or not to use it. There is typically a large number of existing consumers. For each consumer, the choice is to accept the API as it is or leave it. Sometimes there are viable alternative APIs to choose from, but they tend to be made by other big tech companies, meaning they are Mountains too. APIs provided by big tech companies are likely to be covered by broad service level agreements. Communication channels tend to be indirect, through various layers of customer support. Larger customers may have better communication channels.</p>
<p>Mountain APIs are extremely stable once they have reached general availability. They rarely evolve at all, since that would risk breaking any number of consumers. Hence if the API changes, it is through a cataclysmic event where the provider unilaterally decides to deprecate the current API, turning the Mountain into a Volcano. Luckily it tends to be a controlled eruption in the sense that some time is allowed for consumers to evacuate. But the effect is that the old Mountain is obliterated. In the best case the old API is replaced by a new API, which may require more or less substantial changes to the consumers, and may or may not satisfy their needs. In the worst case there is no replacement, and the consumer is left to work out what it means for them and what to do. The impact of this depends on how important the API is to the consumer, ranging from the inconvenient to Pompeii.</p>
<p>The Mountain is not an anti-pattern, and there are no obvious alternatives to it. To the extent that you need to use an API provided by a big tech company in your software system, you will naturally find yourself in the Mountain pattern. You will have to go to the API, it will not come to you.</p>
<h3 id="rapids">The Rapids (with or without Beaver Dams)</h3>
<!-- ### <a name="rapids">The Rapids (with or without Beaver Dams)</a> -->
<p>Rapids: API in the middle of a value stream, provider and consumer needs constant collaboration but are not always in sync or share priorities. Sometimes they build beaver dams to decouple, which is really an anti-pattern. You don’t want beaver dams in your value stream. Maybe the teams should consider merging.</p>
<p>The Rapids pattern describes the scenario where you have an API in the middle of a value stream. It is a very prevalent and dubious pattern. The prototypical example is when you have a backend team and a frontend team working on the same product. The backend team becomes the API provider and the frontend team the API consumer. The API naturally becomes extremely volatile, since each new product feature requires additions to the API, as well as potential other changes as well. Neither team can deliver any value by themselves.</p>
<p>Teams in the Rapids pattern face a choice of constant collaboration and staying in lockstep or inviting one or more socio-technical dysfunctions. Often teams will choose the latter, consciously or inadvertently. There are some socio-technical forces that contribute to this. Indeed, one might wonder why there are two teams of it not to accomplish the opposite; that is independence and autonomy. While the participation of both provider and consumer is required to deliver value, there is no guarantee that any given feature will take an equal amount of time and effort on both sides. There are natural variations in the pace of work making it seem wasteful to remain in sync. But of course asynchrony leads to much less efficient communication since information and context decay quickly. Common psychological factors come into play as well (e.g. preferring written asynchronous communication and working alone to face-to-face communication and working together). Tribal factors strengthen these tendencies.</p>
<p>Sometimes the teams go all in in this direction and try to “decouple” from the other team. For instance the frontend team might build their own “backend-for-frontend” API in front of the backend API, or the teams may agree on using something like GraphQL for the API. The idea is to solve the social problem of collaboration through technical means, by reducing the need for communication and negotiation. This is tantamount to building a beaver dam in the rapids. It is a very bad idea for obvious reasons. Beaver dams inhibit flow. You don’t want beaver dams in your value streams.</p>
<p>Moving away from the Rapids pattern is a “inverse Conway” kind of problem. It’s easiest to start by merging the teams, to get rid of the social inhibitions to communication and collaboration. Sometimes this results in a single team that is “too big”. For instance, you may find that it violates the oft-quoted “two pizza” rule. There are at least three obvious solutions to this that avoid the frontend/backend partitioning of teams. The first is to challenge the idea that the team is too big. Maybe it is, and may it isn’t. As long as the communication improves when you merge the teams, the situation has improved. The second is reduce the size of the merged team. You might find that the improved flow makes up for the reduced headcount. The third is to look for vertical partitionings rather than horizontal ones. That is, make thinner value streams.</p>
<h3 id="sock-puppet">The Sock Puppet</h3>
<!-- ### <a name="sock-puppet"> The Sock Puppet -->
<p>In the Sock Puppet pattern, a team is talking to itself through an API. That is, one team is both producer and consumer of the API. The Sock Puppet is not necessarily an anti-pattern. If you’re making a Single Page Application (SPA), you basically have the choice between the Rapids and the Sock Puppet. In that case, the Sock Puppet is preferable for the reasons described above. In other cases, it may be worth revisiting the reason for having an API. What benefits do you get? Does they outweigh the costs? In other words, is it worth it? This is particularly the case for APIs that change often.</p>
<p>You should also beware if you start getting a large number of socks. Exactly what constitutes a large number may vary, but it may be worth recalling that a human has only two hands, and so can only manipulate two puppets with anything resembling ease and elegance. The number may be similarly low for teams.</p>
<p>Microservice architectures run this risk. A well-modularized system of microservices with stable APIs might be able to reap the purported architectural benefits like scalability, fault isolation, faster deployment and cost efficiency. If you find yourself doing shotgun surgery on multiple Sock Puppets and have to coordinate deployments every time you make a change, however, you should consider merging services. It may be that there is no natural, stable API between your Sock Puppets. In that case you should eliminate the API and have a single process or at least fewer, more coarse-grained services.</p>
<h2>Summary</h2>
<p>When we connect software systems through APIs, we also connect the people who work on those systems. The socio-technical context of the APIs is important both for the provider and the consumer of the API. Common socio-technical forces such as economics and psychological factor tends to favor certain patterns of relationships between provider and consumer. In this blog post, I have described four such patterns that I have observed many times during my career. I hope describing them as I see them will prove useful to you. And with luck, perhaps you will be inspired to describe some patterns that you have observed as well. That would make me very happy.</p>
</body></html>