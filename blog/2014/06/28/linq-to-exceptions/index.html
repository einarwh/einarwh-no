<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><link rel="icon" sizes="any" type="image/svg+xml" href="/images/3d4226764423/favfish.svg"><script data-goatcounter="https://einarwh.goatcounter.com/count" async="" src="https://gc.zgo.at/count.js"></script><script src="/js/0486e9205f01/highlight.min.js"></script><script>hljs.highlightAll();</script><title>LINQ to Exceptions | einarwh</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta property="og:title" content="LINQ to Exceptions"><meta property="og:url" content="https://einarwh.no/blog/2014/06/28/linq-to-exceptions/"><link rel="stylesheet" href="/bundles/3bb5cc0e0a53/app.css"></head><body><header><div id="blog-header"><span style="display:inline-block"><a href="/">einarwh</a></span><span style="float: right;"><a href="/feed/atom.xml">feed</a></span></div><hr></header><h1>LINQ to Exceptions</h1>
<p class="blog-post-date">June 28, 2014</p>
<p>Lately I’ve been thinking about the mundane task of <em>exception handling</em>. Remarkably unsexy, and yet completely mandatory. There’s no escape from handling the exceptions that may (and therefore will) occur in your application, unless you want it to crash or misbehave regularly.</p>
<p>Proper exception handling can be a chore anywhere in your application, but in particular at integration points. Whenever your application needs to communicate with some external service, any number of things can go wrong, at various levels in the stack - from application level errors to network problems. We need to be able to cope with all these different kinds of errors, and hence we surround each service call with a veritable flood of exception handlers. That sort of works, but there are problems - first, the actual service is drowning amidst all the exception handling, and second, we get a lot of code duplication, since we tend to handle many kinds of exceptions in the same way for all service calls.</p>
<p>I’ve been discussing how to best solve this problem in a completely general and flexible way in several impromptu popsicle- and coffee-driven sessions with some of my compatriots at work (in particular Johan and Jonas - thanks guys!). Some of the code examples in this blog post, especially those who exhibit some trace of intelligence, can legitimately be considered rip-offs, evolutions, misunderstandings or various other degenerations of similar code snippets they have come up with.</p>
<p>But I’m getting ahead of myself. Let’s return to the root of the problem: how exception handling code has a tendency to overshadow the so-called business logic in our applications and to cause severe cases of duplication.</p>
<p>The problem is minor if there is a single exception we’re catching:</p>
<pre><code class="language-csharp">try {
  // Interesting code.
}
catch (SomeException ex) {
  // Dull exception handling code.
}
</code></pre>
<p>However, things regress quickly with additional types of exceptions:</p>
<pre><code class="language-csharp">try {
  // Interesting code.
}
catch (SomeException ex) {
  // Dull code.
}
catch (SomeOtherException ex) {
  // Dull code.
}
catch (YetAnotherException ex) {
  // Dull code.
}
catch (Exception ex) {
  // Dull code.
}
</code></pre>
<p>This is a bit messy, and the signal-to-noise-ratio is low. It gets much worse when you have a second piece of interesting code that you need to guard with the same exception handling. Suddenly you have rampant code repetition on your hands.</p>
<p>A solution would be to use a closure to inject the interesting code into a generic exception handling method, like this:</p>
<pre><code class="language-csharp">TR Call&lt;TR&gt;(Func&lt;TR&gt; f) {
  try {
    return f();
  }
  catch (SomeException ex) {
    // Dull code.
  }
  catch (SomeOtherException ex) {
    // Dull code.
  }
  catch (YetAnotherException ex) {
    // Dull code.
  }
  catch (Exception ex) {
    // Dull code.
  }
}
</code></pre>
<p>And then you can use this in your methods:</p>
<pre><code class="language-csharp">Foo SafeMethod1(int x, string s) {
  Call(() =&gt; Method1(x, s));
}

Bar SafeMethod2(double d) {
  Call(() =&gt; Method2(d));
}
</code></pre>
<p>Adding another method is trivial:</p>
<pre><code class="language-csharp">Quux SafeMethod3() {
  Call(() =&gt; Method3());
}
</code></pre>
<p>This works pretty nicely and solves our immediate issue. But there are a couple of limitations. In particular, three problems spring to mind:</p>
<ol>
<li>What if you want to return some legal, non-default value of type <strong>TR</strong> from one or more of the catch-blocks? As it stands now, each catch-block must either rethrow or return the default value of <strong>TR</strong>.</li>
<li>What if there are variations in how you want to handle some of the exceptions? For instance, it may be that <strong>YetAnotherException</strong> should be handled differently for each method.</li>
<li>What if there are slight variations between the “catching” needs for the various methods? What if you decided that <strong>SafeMethod2</strong> doesn’t need to handle <strong>SomeOtherException</strong>, whereas <strong>SafeMethod3</strong> should handle <strong>IdiosyncraticException</strong> in addition to the “standard” ones?</li>
</ol>
<p>As an answer to the two first problems, you could pass in each exception handler to the <strong>Call</strong> method! Then you would have a method like this:</p>
<pre><code class="language-csharp">TR Call&lt;TR&gt;(
  Func&lt;TR&gt; f,
  Func&lt;SomeException, TR&gt; h1,
  Func&lt;SomeOtherException, TR&gt; h2,
  Func&lt;YetAnotherException, TR&gt; h3,
  Func&lt;Exception, TR&gt; h4)
{
  try {
    return f();
  }
  catch (SomeException ex) {
    return h1(ex);
  }
  catch (SomeOtherException ex) {
    return h2(ex);
  }
  catch (YetAnotherException ex) {
    return h3(ex);
  }
  catch (Exception ex) {
    return h4(ex);
  }
}
</code></pre>
<p>And at this point you’re about to stop reading this blog post, because WTF. Now your methods look like this:</p>
<pre><code class="language-csharp">Foo SafeMethod1(int x, string s) {
  Call(() =&gt; Method1(x, s),
    ex =&gt; // Handle SomeException,
    ex =&gt; // Handle SomeOtherException,
    ex =&gt; // Handle YetAnotherException,
    ex =&gt; // Handle Exception
  );
}
</code></pre>
<p>So we’re pretty much back at square one, except it’s a bit more convoluted and confusing for the casual reader. And we still don’t have a good solution for the third problem. We could of course fake “non-handling” of <strong>SomeOtherException</strong> for <strong>SafeMethod2</strong> by simply handing in a non-handling handler, that is, one that simply rethrows directly: <code>ex =&gt; { throw ex; }</code>. But that’s ugly and what about the <strong>IdiosyncraticException</strong>? Well, it’s not going to be pretty:</p>
<pre><code class="language-csharp">Quux SafeMethod3() {
  try {
    return Call(() =&gt; Method3(),
       ex =&gt; // Handle SomeException,
       ex =&gt; // Handle SomeOtherException,
       ex =&gt; // Handle YetAnotherException,
       ex =&gt; // Handle Exception
    );
  }
  catch (IdiosyncraticException ex) {
    // Do something.
  }
}
</code></pre>
<p>Which just might be the worst code ever, and also has the idiosyncracy that the additional catch-handler will only be reached if the <strong>Exception</strong> handler rethrows. Horrible. Better, perhaps, to put it inside?</p>
<pre><code class="language-csharp">Quux SafeMethod3() {
  return Call(() =&gt;
    {
      try { return Method3(); } catch (IdiosyncraticException ex) { throw ex; }
    },
    ex =&gt; // Handle SomeException,
    ex =&gt; // Handle SomeOtherException,
    ex =&gt; // Handle YetAnotherException,
    ex =&gt; // Handle Exception
  );
}
</code></pre>
<p>Well yes, slightly better, but still pretty horrible, and much worse than just suffering the duplication in the first place. But maybe we’ve learned something. What we need is composition - our current solution doesn’t compose at all. we need to be able to put together exactly the exception handlers we need for each method, while at the same time avoiding repetition. The problem is in some sense the coupling between the exception handlers. What if we tried a different approach, handling a single exception at a time?</p>
<p>We could have a less ambitious <strong>Call</strong>-method, that would handle just a single type of exception for a method. Like this:</p>
<pre><code class="language-csharp">TR Call&lt;TR, TE&gt;(
  Func&lt;TR&gt; f,
  Func&lt;TE, TR&gt; h)
  where TE : Exception
{
  try {
    return f();
  }
  catch (TE ex) {
    return h(ex);
  }
}
</code></pre>
<p>Now we have a single generic exception handler <strong>h</strong>. Note that when we constrain the type variable <strong>TE</strong> to be a subclass of <strong>Exception</strong>, we can use <strong>TE</strong> in the catch clause, to select precisely the exceptions we would like to catch. Then we could write a method like this:</p>
<pre><code class="language-csharp">Frob SafeMethod4a() {
  return Call(
    () =&gt; new Frob(),
    (NullReferenceException ex) =&gt; ... );
}
</code></pre>
<p>What if we wanted to catch another exception as well? The solution is obvious:</p>
<pre><code class="language-csharp">Frob SafeMethod4b() {
  return Call(
    () =&gt; SafeMethod4a(),
    (InvalidOperationException ex) =&gt; ... );
}
</code></pre>
<p>And yet another exception?</p>
<pre><code class="language-csharp">Frob SafeMethod4c() {
  return Call(
    () =&gt; SafeMethod4b(),
    (FormatException ex) =&gt; ... );
}
</code></pre>
<p>You get the picture. Of course, we can collapse all three to a single method if we want to:</p>
<pre><code class="language-csharp">Frob SafeMethod4() {
  return
    Call(() =&gt;
      Call(() =&gt;
        Call(() =&gt;
          FrobFactory.Create(),
          (NullReferenceException ex) =&gt; ... ),
        (InvalidOperationException ex) =&gt; ... ),
      (FormatException ex) =&gt; ... );
}
</code></pre>
<p>What have we gained? Well, not readability, I’ll admit that. But we’ve gained flexibility! Flexibility goes a long way! And we’ll work on the readability shortly. First, though: just in case it’s not clear, what we’ve done is that we’ve created an exception handling scenario that is similar to this:</p>
<pre><code class="language-csharp">Frob TraditionalSafeMethod4() {
  try {
    try {
      try {
        return FrobFactory.Create();
      }
      catch (NullReferenceException ex) { ... handler code ... }
    }
    catch (InvalidOperationException ex) { ... handler code ... }
  }
  catch (FormatException ex) { ... handler code ... }
}
</code></pre>
<p>So there’s nothing very complicated going on here. In fact, I bet you can see how similar the two methods really are - the structure is identical! All we’ve done is replace the familiar <em>try-catch</em> construct with our own <strong>Call</strong>-construct.</p>
<p>As an aside, we should note that the composed try-catch approach has slightly different semantics than the sequential, coupled try-catch approach. The difference in semantics is due to decoupling provided by the composed try-catch approach - each catch-block is completely independent. Therefore, there is nothing stopping us from having multiple catch-handlers for the <em>same</em> type of exception should we so desire.</p>
<p>Now, to work on the readability a bit. What we really would like is some way to attach catch-handlers for various exception types to our function call. So assuming that we wrap up our original function call in a closure using a delegate of type <strong>Func&lt;TR&gt;</strong>, we would like to be able to attach a catch-handler for some exception type <strong>TE</strong>, and end up with a new closure that still has the type <strong>Func&lt;TR&gt;</strong>. Then we would have encapsulated the exception handling completely. Our unambitious <strong>Call</strong>-method from above is almost what we need, but not quite. Instead, let’s define an extension method on the type that we would like to extend! <strong>Func&lt;TR&gt;</strong>, that is:</p>
<pre><code class="language-csharp">static class CatchExtensions
{
  static Func&lt;TR&gt; Catch&lt;TR, TE&gt;(
    this Func&lt;TR&gt; f,
    Func&lt;TE, TR&gt; h)
  where TE : Exception
  {
    return () =&gt; {
      try {
        return f ();
      } catch (TE ex) {
        return h (ex);
      };
    };
  }
}
</code></pre>
<p>So the trick is to return a new closure that encapsulates calling the original closure and the exception handling. Then we can write code like this:</p>
<pre><code class="language-csharp">Frob ExtSafeMethod4() {
  Func&lt;Frob&gt; it = () =&gt; FrobFactory.Create();
  var safe =
    it.Catch((NullReferenceException ex) =&gt; ... )
      .Catch((InvalidOperationException ex) =&gt; ... )
      .Catch((FormatException ex) =&gt; ... );
  return safe();
}
</code></pre>
<p>Now the neat thing is that you can very easily separate out the catch-handler-attachment from the rest of the code:</p>
<pre><code class="language-csharp">Frob ExtSafeMethod4b() {
  var safe = Protect(() =&gt; FrobFactory.Create);
  return safe();
}

Func&lt;TR&gt; Protect&lt;TR&gt;(Func&lt;TR&gt; it) {
  return
    it.Catch((NullReferenceException ex) =&gt; ... )
      .Catch((InvalidOperationException ex) =&gt; ... )
      .Catch((FormatException ex) =&gt; ... );
}
</code></pre>
<p>So we have essentially created a fluent interface for attaching catch-handlers to a method call. The cool thing is that it is trivial to attach additional exception handlers as needed - and since we do so programmatically, we can even have logic to control the attachment of handlers. Say we discovered that we needed to catch <strong>WerewolfException</strong>s when the moon is full? No problem:</p>
<pre><code class="language-csharp">Func&lt;Frob&gt; WolfProof() {
  var f = Protect(() =&gt; FrobFactory.Create());
  if (IsFullMoon()) {
    f = f.Catch((WerewolfException ex) =&gt; ... ); // silver bullet?
  }
  return f;
}
</code></pre>
<p>In my eyes, this is pretty cool. You might be running away screaming, thinking I’m crazy and that with this approach, you’ll never know which exceptions you’re actually catching anymore. You could be right. Opinions differ.</p>
<p>But that’s OK. All I’m doing is providing an alternative approach to the handling of multiple exception - one that I think offers increased power and flexibility. I’m not saying you should take advantage of it. With greater power comes greater responsibility and all that.</p>
<p>And besides, we still haven’t talked about Linq. An alternative (and attractive) solution to our current fluent interface is to attach a sequence of catch-handlers at once. Something like this:</p>
<pre><code class="language-csharp">// Unfortunately, this won't compile.
Func&lt;TR&gt; Protect&lt;TR&gt;(Func&lt;TR&gt; it) {
  return
    it.CatchAll(
      (NullReferenceException ex) =&gt; ... ,
      (InvalidOperationException ex) =&gt; ... ,
      (FormatException ex) =&gt; ... );
}
</code></pre>
<p>However, it’s surprisingly difficult to provide a suitable type for that sequence of catch-handlers - in fact, the C# compiler fails to do so! The problem is that delegates are contravariant in their parameters, which means that a delegate <strong>D1</strong> is considered a <em>subtype</em> of delegate <strong>D2</strong> if the parameters of <strong>D1</strong> are <em>supertypes</em> of the parameters of <strong>D2</strong>. That’s all a bit abstract, so perhaps an example will help:</p>
<pre><code class="language-csharp">Action&lt;object&gt; d1 = (object o) =&gt; {};
Action&lt;string&gt; d2 = (string s) =&gt; {};

d1 = d2; // This won't compile.
d2 = d1; // This is OK.
</code></pre>
<p>To make sense of the abstract description above, assume that <strong>D1</strong> is <strong>Action&lt;object&gt;</strong> and <strong>D2</strong> is <strong>Action&lt;string&gt;</strong>. Since the <strong>D1</strong> parameter (<strong>object</strong>) is a supertype of the <strong>D2</strong> parameter (<strong>string</strong>), it follows that <strong>D1</strong> is a subtype of <strong>D2</strong> - and not the other way around, as we might have guessed. This is why the C# compiler won’t let us assign a <strong>D2</strong> instance to a <strong>D1</strong> reference.</p>
<p>The implication is that the C# compiler will fail to find a type that will reconcile the catch handlers above. In particular, due to the contravariance of delegate parameters, we cannot type the sequence as <strong>Func&lt;Exception, TR&gt;</strong>, since neither <strong>Func&lt;NullReferenceException, TR&gt;</strong>, nor <strong>Func&lt;InvalidOperationException, TR&gt;</strong>, nor <strong>Func&lt;FormatException, TR&gt;</strong> are assignable to <strong>Func&lt;Exception, TR&gt;</strong>. It would go the other way around: we could assign a <strong>Func&lt;Exception, TR&gt;</strong> to all three of the other types, but which one should the compiler pick? If it (arbitrarily) picked <strong>Func&lt;&lt;NullReferenceException, TR&gt;</strong>, clearly it wouldn’t work for the two other delegates - and all other choices have the same problem.</p>
<p>So we’re stuck. Sort of. The only solution we have is to <em>hide</em> the exception type somehow, so that we don’t have to include the exception type in the type of the sequence. Now how do we do that? Well, in some sense, we’ve already seen an example of how to do that: we hide the exception handling (and the type) inside a closure. So all we need is some way to convert an exception handler to a simple transformation function that doesn’t care about the type of the exception itself. Like this:</p>
<pre><code class="language-csharp">Func&lt;Func&lt;TR&gt;, Func&lt;TR&gt;&gt; Encapsulate&lt;TR, TE&gt;(Func&lt;TE, TR&gt; h)
  where TE : Exception
{
  return f =&gt; () =&gt;
  {
    try {
      return f();
    }
    catch (TE ex) {
      return h(ex);
    };
  };
}
</code></pre>
<p>So what is this thing? It’s a method that encapsulates the catch-handler inside a closure. This closure will take as input a closure of type <strong>Func&lt;TR&gt;</strong> and produce as output another closure of type <strong>Func&lt;TR&gt;</strong>. In the process, we have hidden the type <strong>TE</strong>, so that the C# compiler doesn’t have to worry about it anymore: all we have is a thing that will transform a <strong>Func&lt;TR&gt;</strong> to another <strong>Func&lt;TR&gt;</strong>.</p>
<p>So now we can sort of accomplish what we wanted, even though it’s less than perfect.</p>
<pre><code class="language-csharp">Func&lt;TR&gt; Protect&lt;TR&gt;(Func&lt;TR&gt; it) {
  return
    it.CatchAll(
      Encapsulate((NullReferenceException ex) =&gt; ...),
      Encapsulate((InvalidOperationException ex) =&gt; ...),
      Encapsulate((FormatException ex) =&gt; ... ));
}
</code></pre>
<p>But now we can have some fun using Linq’s <strong>Aggregate</strong> method to compose our exception handlers. So we might write code like this:</p>
<pre><code class="language-csharp">var catchers = new [] {
  Encapsulate((ArgumentException x) =&gt; x.Message),
  Encapsulate((InvalidOperationException x) =&gt; { Log(x.Message); throw x; },
  Encapsulate((NullReferenceException x) =&gt; "Uh oh")
};

var protect = catchers.Aggregate((acc, nxt) =&gt; thing =&gt; nxt(acc(thing)));

var f = protect(() =&gt; FetchStringSomewhere());

var s = f();
</code></pre>
<p>The cool part is obviously the <strong>Aggregate</strong> call, where <strong>acc</strong> is the “accumulated” composed closure, <strong>nxt</strong> is the next encapsulated exception handler and <strong>thing</strong> is the thing we’re trying to protect with our exception handlers - so in other words, the closure that contains the call to <strong>FetchStringSomewhere</strong>.</p>
<p>And of course we can now implement <strong>CatchAll</strong> if we want to:</p>
<pre><code class="language-csharp">static class CatchExtensions
{
  Func&lt;TR&gt; CatchAll&lt;TR&gt;(
    this Func&lt;TR&gt; f,
    params Func&lt;Func&lt;TR&gt;, Func&lt;TR&gt;&gt;[] catchers)
  {
    var protect = catchers.Aggregate((acc, nxt) =&gt; thing =&gt; nxt(acc(thing)));
    return protect(f);
  }
}
</code></pre>
<p>Now please, if you are Eric Lippert and can come up with code that proves that I’m wrong with respect to the typing of sequences of exception handler delegates - please let me know! I would very much like to be corrected if that is the case.</p>
</body></html>