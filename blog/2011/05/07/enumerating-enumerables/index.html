<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><link rel="icon" sizes="any" type="image/svg+xml" href="/images/3d4226764423/favfish.svg"><script data-goatcounter="https://einarwh.goatcounter.com/count" async="" src="https://gc.zgo.at/count.js"></script><script src="/js/0486e9205f01/highlight.min.js"></script><script>hljs.highlightAll();</script><title>Enumerating enumerables | einarwh</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta property="og:title" content="Enumerating enumerables"><meta property="og:url" content="https://einarwh.no/blog/2011/05/07/enumerating-enumerables/"><link rel="stylesheet" href="/bundles/3bb5cc0e0a53/app.css"></head><body><header><div id="blog-header"><span style="display:inline-block"><a href="/">einarwh</a></span><span style="float: right;"><a href="/feed/atom.xml">feed</a></span></div><hr></header><h1>Enumerating enumerables</h1>
<p class="blog-post-date">May 7, 2011</p>
<p>You know when you’re iterating over some <strong>IEnumerable</strong>, and you need to associate the items in the <strong>IEnumerable</strong> with a sequence number?</p>
<p>In Python, you could do this:</p>
<p><img src="/images/b53efb6b5f84/python-enumerate-shell.png" alt="Python solution for indexed enumeration."></p>
<p>In C#, however, you’re forced to do something like this:</p>
<pre><code class="language-csharp">var items = new [] { "zero", "one", "two" };
int no = 0;
foreach (var it in items) 
{
  Console.WriteLine("{0} =&gt; {1}", no, it);
  ++no;
}
</code></pre>
<p>Yuck. I feel dirty each time. It’s two measly lines of code, but it sure feels like I’m nailing something onto the loop that doesn’t belong there. (And that’s probably because that’s exactly what I’m doing.) It feels out of sync with the level of abstraction for the <strong>foreach</strong> statement, and it’s just plain ugly. So what I’m looking for is an approach that’s more appealing aesthetically, something a little more polished, something like:</p>
<pre><code class="language-csharp">var items = new [] { "zero", "one", "two" };
foreach (var it in items.Enumerate()) 
{
  Console.WriteLine("{0} =&gt; {1}", it.Number, it.Item);
}
</code></pre>
<p>To be sure, this is still not as clean as the Python code (for one, there’s no decomposition of tuple types).  But personally, I like it a whole lot better than the original C# version. It’s prettier, cleaner, and plugs the leaky abstraction.</p>
<p>As you can imagine, I’m using an extension method to pretend that <strong>IEnumerable</strong>s can be, you know, enumerated. The task of the extension method is just to turn an <strong>IEnumerable&lt;T&gt;</strong> into an <strong>IEnumerable&lt;Enumerated&lt;T&gt;&gt;</strong>, like so:</p>
<pre><code class="language-csharp">public static IEnumerable&lt;Enumerated&lt;T&gt;&gt; Enumerate&lt;T&gt;(this IEnumerable&lt;T&gt; e)   
{  
  int i = 0;  
  return e.Select(it =&gt; new Enumerated&lt;T&gt;(i++, it));  
}
</code></pre>
<p>And <strong>Enumerated&lt;T&gt;</strong> is just a necessary evil to appease the C# compiler:</p>
<pre><code class="language-csharp">class Enumerated&lt;T&gt;
{
  private readonly int _number;
  private readonly T _;

  public Enumerated(int number, T t)
  {
    _number = number;
    _ = t;
  }

  public int Number
  {
    get { return _number; }
  }

  public T Item
  {
    get { return _; }
  }
}
</code></pre>
<p>It is easy to augment types with arbitrary information this way; sequence numbers is just one example. For a general solution, though, you probably wouldn’t want to keep writing these plumbing wrappers like <strong>Enumerated&lt;T&gt;</strong>. It’s not just that your brain would go numb, you also need something more versatile, something that’s not bound to the specific type of information you’re augmenting with. The task-specific types are an obstacle to a simple, generic and flexible implementation.</p>
<p>A solution is to use the <strong>Tuple&lt;T1, T2&gt;</strong> type introduced in .NET 4. It’s sort of a compromise, though, and I don’t quite like it. Since it is a generic tuple, the names of the properties are meaningless (<strong>Item1</strong> and <strong>Item2</strong>), and I believe rather firmly that names should be meaningful. However, using the <strong>Tuple&lt;T1, T2&gt;</strong> type makes it very easy to generalize the augmentation process. Here’s how you could go about it:</p>
<pre><code class="language-csharp">public static IEnumerable&lt;Tuple&lt;T, T1&gt;&gt; Augment&lt;T, T1&gt;(this IEnumerable&lt;T&gt; e, Func&lt;T1&gt; aug)
{
  return e.Select(it =&gt; Tuple.Create(it, aug()));
}
</code></pre>
<p>You can use <strong>Augment</strong> directly, like so:</p>
<pre><code class="language-csharp">foreach (var it in items.Augment(() =&gt; Guid.NewGuid()))
{
  Console.WriteLine("{0} =&gt; {1}", it.Item2, it.Item1);
}
</code></pre>
<p>In this case, I’m augmenting each item with a <strong>Guid</strong>. Here’s the output:</p>
<p><img src="/images/8790b907f8b7/csharp-augment-prompt.png" alt="Augmenting with a Guid."></p>
<p>This is convenient for one-off scenarios. If you’re going to augment types the same way multiple times, though, you might go through the trouble of defining some extension methods:</p>
<pre><code class="language-csharp">public static IEnumerable&lt;Tuple&lt;T, int&gt;&gt; Enumerate&lt;T&gt;(this IEnumerable&lt;T&gt; e)
{
  int i = 0;
  return Augment(e, () =&gt; i++);
}

public static IEnumerable&lt;Tuple&lt;T, DateTime&gt;&gt; WithTimestamps&lt;T&gt;(this IEnumerable&lt;T&gt; e)
{
  return Augment(e, () =&gt; DateTime.Now);
}

public static IEnumerable&lt;Tuple&lt;T, Guid&gt;&gt; WithGuids&lt;T&gt;(this IEnumerable&lt;T&gt; e)
{
  return Augment(e, Guid.New);
}
</code></pre>
<p>And so on and so forth, for all your clever augmentation needs.</p>
<p>Then your code would look like this:</p>
<pre><code class="language-csharp">foreach (var it in items.WithGuids())
{
  Console.WriteLine("{0} =&gt; {1}", it.Item2, it.Item1);
}
</code></pre>
<p>Which is pretty neat. If you can stomach <strong>Item1</strong> and <strong>Item2</strong>, that is.</p>
</body></html>