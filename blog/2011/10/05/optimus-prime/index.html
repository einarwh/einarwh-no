<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><link rel="icon" sizes="any" type="image/svg+xml" href="/images/3d4226764423/favfish.svg"><script data-goatcounter="https://einarwh.goatcounter.com/count" async="" src="https://gc.zgo.at/count.js"></script><title>Optimus Prime | einarwh</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta property="og:title" content="Optimus Prime"><meta property="og:url" content="https://einarwh.no/blog/2011/10/05/optimus-prime/"><link rel="stylesheet" href="/bundles/5326b1f5d38c/app.css"></head><body><header><div id="blog-header"><span style="display:inline-block"><a href="/">einarwh</a></span><span style="float: right;"><a href="/feed/atom.xml">feed</a></span></div><hr></header><h1>Optimus Prime</h1>
<p class="blog-post-date">October 5, 2011</p>
<p>Iterators, man. They’re so much fun.</p>
<p>I’ve messed about with <strong>IEnumerable&lt;T&gt;</strong> a little bit before, even in the short history of this blog, but I don’t feel like I can say I’ve done so in anger. Sort of the litmus test to see if you’ve grokked lazy evaluation is to implement an infinite sequence of some sort, wouldn’t you agree? Until you do that it’s all talk and no walk. So I thought I’d rectify that, to be a certified <strong>IEnumerable&lt;T&gt;</strong>-grokker. You in?</p>
<p>We’ll start gently. The simplest example of an infinite sequence that I can think of is this:</p>
<blockquote>
<p>1, 2, 3, 4, 5…</p>
</blockquote>
<p>You’re absolutely right, it’s the sequence of positive integers!</p>
<p>There are actually two simple ways to implement an <strong>IEnumerable&lt;int&gt;</strong> that would give you that. First off, you could write the dynamic duo of <strong>IEnumerable&lt;int&gt;</strong> and <strong>IEnumerator&lt;int&gt;</strong> that conspire to let you write code using the beloved <strong>foreach</strong> keyword. As you well know, <strong>foreach</strong> over an <strong>IEnumerable&lt;T&gt;</strong> compiles to IL that will obtain an <strong>IEnumerator&lt;T&gt;</strong> and use <em>that</em> to do the actual iteration. (I was going to write <em>iterate over</em> here, but that sort of presupposes that you’ve got something finite that you’re stepping through, doesn’t it?)</p>
<p>Anyways, first implementation:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Incrementer</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">IncrementingEnumerator</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">IncrementingEnumerator</span> <span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="kt">int</span> <span class="n">_n</span><span class="p">;</span>

  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="p">++</span><span class="n">_n</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">int</span> <span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_n</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Current</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Reset</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">_n</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>An alternative implementation would be this:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">ContinuationIncrementer</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">yield</span> <span class="k">return</span> <span class="p">++</span><span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>This is simpler in terms of lines of code, but it requires you to understand what the <strong>yield</strong> keyword does. So what <em>does</em> the <strong>yield</strong> keyword do? Conceptually, <strong>yield</strong> gives you what is known as a <em>continuation</em>. In essence, it allows you to jump right back into the code where you left off at the previous step in the iteration. Of course, the best way to find out what is going on under the hood is to look at the IL. If you do that, you’ll see that what the C# compiler actually does is conjure up an <strong>IEnumerator&lt;int&gt;</strong> of its own. This generated class essentially performs the same task as our handwritten <strong>IncrementingEnumerator</strong>.</p>
<p>Unsurprisingly, then, the end result is the same, regardless of the implementation we choose. What <strong>Incrementer</strong> gives you is an infinite sequence of consecutive positive integers, starting with 1. So if you have code like this:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="k">in</span> <span class="k">new</span> <span class="n">Incrementer</span><span class="p">())</span>
<span class="p">{</span>
  <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> 
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">==</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span> 
<span class="p">}</span>
</code></pre>
<p>That’s going to print the numbers 1 through 10. And since there’s no built-in way to stop the <strong>Incrementer</strong>, it’s fairly important to break out of that loop!</p>
<p>That’s not terribly interesting, though. Although it might be worth noting that at least it consumes little memory, since the <strong>IEnumerable&lt;int&gt;</strong> only holds on to a single integer at a time. That’s good. Furthermore, we could generalize it to produce the sequence</p>
<blockquote>
<p>n, 2n, 3n, 4n, 5n…</p>
</blockquote>
<p>instead (without exciting people too much, I guess). We could even provide an additional constructor to enable you to set a start value <em>k</em>, so you’d get the sequence</p>
<blockquote>
<p>n+k, 2n+k, 3n+k, 4n+k, 5n+k…</p>
</blockquote>
<p><em>Still not excited?</em> Oh well. There’s no pleasing some people.</p>
<p>Let’s implement it anyway. We’ll call it <strong>NumberSequence</strong> and have it use a <strong>NumberEnumerator</strong> to do the actual work, such as it is (it isn’t much):</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">NumberSequence</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">_startValue</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">_increment</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">NumberSequence</span><span class="p">(</span><span class="kt">int</span> <span class="n">startValue</span><span class="p">,</span> <span class="kt">int</span> <span class="n">increment</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_startValue</span> <span class="p">=</span> <span class="n">startValue</span><span class="p">;</span>
    <span class="n">_increment</span> <span class="p">=</span> <span class="n">increment</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">NumberEnumerator</span><span class="p">(</span><span class="n">_startValue</span><span class="p">,</span> <span class="n">_increment</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">NumberEnumerator</span> <span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;,</span> 
  <span class="n">IComparable</span><span class="p">&lt;</span><span class="n">NumberEnumerator</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">_increment</span><span class="p">;</span>
  <span class="k">private</span> <span class="kt">int</span> <span class="n">_currentValue</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">NumberEnumerator</span><span class="p">(</span><span class="kt">int</span> <span class="n">startValue</span><span class="p">,</span> <span class="kt">int</span> <span class="n">increment</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_currentValue</span> <span class="p">=</span> <span class="n">startValue</span><span class="p">;</span>
    <span class="n">_increment</span> <span class="p">=</span> <span class="n">increment</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">_currentValue</span> <span class="p">+=</span> <span class="n">_increment</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">int</span> <span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_currentValue</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Current</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Reset</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">int</span> <span class="nf">CompareTo</span><span class="p">(</span><span class="n">NumberEnumerator</span> <span class="n">other</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Current</span><span class="p">.</span><span class="n">CompareTo</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">Current</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>You’ll notice that I got a bit carried away and implemented <strong>IComparable&lt;NumberEnumerator&gt;</strong> as well, so that we could compare the state of two such <strong>NumberEnumerator</strong> instances should we so desire.</p>
<p>A completely different, but equally simple way to create an infinite sequence is to repeat the same finite sequence over and over again. You could do that completely generically, by repeating an <strong>IEnumerable&lt;T&gt;</strong>. Like so:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">BrokenRecord</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_seq</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">BrokenRecord</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">seq</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_seq</span> <span class="p">=</span> <span class="n">seq</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">e</span> <span class="p">=</span> <span class="n">_seq</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">();</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">BrokenRecordEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">e</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">BrokenRecordEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_seq</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">BrokenRecordEnumerator</span><span class="p">(</span><span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">seq</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_seq</span> <span class="p">=</span> <span class="n">seq</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{}</span>

  <span class="k">private</span> <span class="kt">bool</span> <span class="nf">ResetAndMoveNext</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">Reset</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">_seq</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">_seq</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">()</span> <span class="p">||</span> <span class="n">ResetAndMoveNext</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Reset</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">_seq</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">T</span> <span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">_seq</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Current</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>So you could write code like this:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="kt">var</span> <span class="n">words</span> <span class="p">=</span> <span class="k">new</span> <span class="p">[]</span> <span class="p">{</span> <span class="s">"Hello"</span><span class="p">,</span> <span class="s">"dear"</span><span class="p">,</span> <span class="s">"friend"</span> <span class="p">};</span> 
<span class="kt">int</span> <span class="n">wordCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> 
<span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">s</span> <span class="k">in</span> <span class="k">new</span> <span class="n">BrokenRecord</span><span class="p">(</span><span class="n">words</span><span class="p">))</span> 
<span class="p">{</span>
  <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(++</span><span class="n">wordCount</span> <span class="p">==</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span> 
<span class="p">}</span>
</code></pre>
<p>And of course the output would be:</p>
<pre class="codehilite"><code><span></span>Hello
dear
friend
Hello
dear
friend
Hello
dear
friend
Hello
</code></pre>
<p>Now you could put a finite sequence of numbers in there, or just about any sequence you like, in fact. Including, as it were, an infinite sequence of some sort - although that wouldn’t be very meaningful, since you’d never see that thing starting over!</p>
<p>So yeah, we’re starting to see how we can create infinite sequences, and it’s all very easy to do. But what can you do with it?</p>
<p>Let’s turn our attention to an archetypical academic exercise: generating a sequence of prime numbers. Now as you well know, prime numbers aren’t as useless as they might seem to the untrained eye - there are practical applications in cryptography and what have you. But we’re not interested in that right now; we’re going for pure academic interest here. Let’s not fool ourselves to think we’re doing anything useful.</p>
<p>A well-known technique for finding prime numbers is called the <em>Sieve of Eratosthenes</em> (a sieve being a device that separates wanted elements from unwanted ones). In a nutshell, the Sieve of Eratosthenes works like this:</p>
<p>You have a finite list of consecutive integers, starting at 2. You take the first number in the list and identify it as a prime. Then you go over the rest of the list, crossing out any multiples of that prime (since obviously multiples of a prime cannot be other primes). Then you take the next number in the list that hasn’t been crossed out. That’s also a prime, so you repeat the crossing out process for that prime. And so on and so forth until you’re done.</p>
<p>Here’s a simple example of the primes from 2-20.</p>
<blockquote>
<p>2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20</p>
</blockquote>
<p>The number 2 is a prime! Cross out all the multiples of 2.</p>
<blockquote>
<p>2  3  X  5  X  7  X  9  X 11  X 13  X 15  X 17  X 19  X</p>
</blockquote>
<p>The number 3 is also a prime! Now cross out all its multiples:</p>
<blockquote>
<p>2  3  X  5  X  7  X  X  X 11  X 13  X  X  X 17  X 19  X</p>
</blockquote>
<p>And we keep going for 5, 7, 11, 13, 17 and 19. As it turns out, all the multiples have already been covered by other prime-multiples, so there are actually no more numbers being crossed out. But algorithmically, we obviously need to go through the same process for all the primes.</p>
<p>Now, a problem with the Sieve of Eratosthenes as it is formulated here, is that it presupposes a finite list of numbers, and hence you get a finite list of primes as well. We want an <em>infinite</em> list, otherwise surely we won’t certify as IEnumerable&lt;T&gt;-grokkers. Luckily, it is possible to adjust the Sieve of Eratosthenes to cope with infinite lists of numbers. There’s a very readable <a href="https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf">paper</a> by Melissa O’Neill that shows how you could go about it. The trick is to do just-in-time elimination of prime-multiples, instead of carrying out the elimination immediately when the prime is found.</p>
<p>Essentially, we maintain an infinite sequence of prime-multiples for each prime we encounter. For each new number we want to check, we check to see if there are pending prime-multiples (i.e. obvious non-primes) matching the number. If there are, the number is <em>not</em> a prime (since we’re looking at a number that would have been eliminated in the finite Sieve of Erastosthenes). The number is discarded just-in-time, and the eliminating sequence(s) of prime-multiples are advanced to the next prime-multiple. If there is no matching prime-multiple in any of the sequences, the number <em>is</em> a brand new prime. This means that we need to add a new infinite sequence of prime-multiples to our collection. In other words, we’re aggregating such sequences as we go along. Luckily, they each hold on to no more than a single integer value (See, I told you that was useful. And you wouldn’t believe me!)</p>
<p>Now how do we keep track of our prime-multiple-sequences? A naive approach would be to keep them all in a list, and just check them all for each candidate number. That wouldn’t be too bad for a small number of primes. However, say you’re looking to see if a number <em>n</em> is the 1001th prime - you’d have to go through all 1000 prime-multiple sequences to see if any of them eliminate <em>n</em> as a candidate. That’s a lot of unnecessary work! What we really need to do, is check the one(s) with the smallest pending prime-multiple. Using a priority queue to hold our sequences makes this an O(1) operation. Unfortunately, the .NET framework doesn’t contain an implementation of a priority queue. Fortunately, the <a href="http://www.itu.dk/research/c5/">C5 Generic Collection Library</a> does. So we’ll use that.</p>
<p>Here, then, is how we could implement an <strong>IEnumerable&lt;int&gt;</strong> that represents an infinite sequence of primes:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">PrimeSequence</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">SimplePrimeEnumerator</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">SimplePrimeEnumerator</span> <span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">_candidates</span> <span class="p">=</span> 
    <span class="k">new</span> <span class="nf">NumberSequence</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">).</span><span class="n">GetEnumerator</span><span class="p">();</span>
  <span class="k">private</span> <span class="n">IPriorityQueue</span><span class="p">&lt;</span><span class="n">NumberEnumerator</span><span class="p">&gt;</span> <span class="n">_pq</span> <span class="p">=</span> 
    <span class="k">new</span> <span class="n">IntervalHeap</span><span class="p">&lt;</span><span class="n">NumberEnumerator</span><span class="p">&gt;();</span>

  <span class="k">public</span> <span class="kt">int</span> <span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_candidates</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">_candidates</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">();</span>
      <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">_candidates</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">_pq</span><span class="p">.</span><span class="n">IsEmpty</span> <span class="p">||</span> <span class="n">n</span> <span class="p">&lt;</span> <span class="n">_pq</span><span class="p">.</span><span class="n">FindMin</span><span class="p">().</span><span class="n">Current</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="c1">// There are no pending prime-multiples.</span>
        <span class="c1">// This means n is a prime!</span>
        <span class="n">_pq</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">NumberEnumerator</span><span class="p">(</span><span class="n">n</span><span class="p">*</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">do</span>
      <span class="p">{</span>
        <span class="kt">var</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">_pq</span><span class="p">.</span><span class="n">DeleteMin</span><span class="p">();</span>
        <span class="n">temp</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">();</span>
        <span class="n">_pq</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="p">==</span> <span class="n">_pq</span><span class="p">.</span><span class="n">FindMin</span><span class="p">().</span><span class="n">Current</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Current</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Reset</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre>
<p>An interesting thing to point out is that the prime-multiple sequence doesn’t have to start until prime*prime. Why? Because smaller multiples of the prime will already be covered by previously considered primes! For instance, the prime-multiple sequence for 17 doesn’t have to contain the multiple 17*11 since the prime-multiple sequence for 11 will contain the same number.</p>
<p>Now this implementation is actually pretty decent. There’s just one thing that leaps to mind as sort of wasted effort. We’re checking <em>every number there is</em> to see if it could possibly be a prime. Yet we know that 2 is the <em>only</em> even number that is a prime (all the others, well, they’d be divisible by 2, right?). So half of our checks are completely in vain.</p>
<p>What if we baked in a little bit of smarts to handle this special case? Say we create a <em>PrimeSequence</em> like so:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">PrimeSequence</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="m">2</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">e</span> <span class="p">=</span> <span class="k">new</span> <span class="n">OddPrimeEnumerator</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">())</span> 
    <span class="p">{</span>
      <span class="k">yield</span> <span class="k">return</span> <span class="n">e</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The <strong>OddPrimeEnumerator</strong> is actually quite similar to the naive <strong>PrimeEnumerator</strong>, except three things:</p>
<ol>
<li>It needs to start at 3 instead of 2, since we already yielded 2 in the <strong>PrimeSequence</strong>.</li>
<li>It needs to skip every other number, so it uses 2 as an increment instead of 1.</li>
<li>The <strong>MoveNext</strong> method can no longer assume that n &lt;= the smallest pending prime-multiple. In fact, it may very well have skipped past a prime-multiple.</li>
</ol>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">OddPrimeEnumerator</span> <span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">_candidates</span> <span class="p">=</span> 
    <span class="k">new</span> <span class="nf">NumberEnumerator</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IPriorityQueue</span><span class="p">&lt;</span><span class="n">NumberEnumerator</span><span class="p">&gt;</span> <span class="n">_pq</span> <span class="p">=</span> 
    <span class="k">new</span> <span class="n">IntervalHeap</span><span class="p">&lt;</span><span class="n">NumberEnumerator</span><span class="p">&gt;();</span>

  <span class="k">public</span> <span class="kt">int</span> <span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_candidates</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">_candidates</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">();</span>
      <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">_candidates</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="n">crossedOut</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(!</span><span class="n">crossedOut</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_pq</span><span class="p">.</span><span class="n">IsEmpty</span> <span class="p">||</span> <span class="n">n</span> <span class="p">&lt;</span> <span class="n">_pq</span><span class="p">.</span><span class="n">FindMin</span><span class="p">().</span><span class="n">Current</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="c1">// There are no pending prime-multiples.</span>
          <span class="c1">// This means n is a prime!</span>
          <span class="n">_pq</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">NumberEnumerator</span><span class="p">(</span><span class="n">n</span> <span class="p">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
          <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">crossedOut</span> <span class="p">=</span> <span class="n">n</span> <span class="p">==</span> <span class="n">_pq</span><span class="p">.</span><span class="n">FindMin</span><span class="p">().</span><span class="n">Current</span><span class="p">;</span>
        <span class="k">do</span>
        <span class="p">{</span>
          <span class="kt">var</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">_pq</span><span class="p">.</span><span class="n">DeleteMin</span><span class="p">();</span>
          <span class="n">temp</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">();</span>
          <span class="n">_pq</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="p">&gt;</span> <span class="n">_pq</span><span class="p">.</span><span class="n">FindMin</span><span class="p">().</span><span class="n">Current</span><span class="p">)</span> <span class="p">||</span>
                 <span class="p">(</span><span class="n">crossedOut</span> <span class="p">&amp;&amp;</span> <span class="n">n</span> <span class="p">==</span> <span class="n">_pq</span><span class="p">.</span><span class="n">FindMin</span><span class="p">().</span><span class="n">Current</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Current</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Reset</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Note that we must go out of our way a little bit to handle the case where we skip past a prime-multiple. Hence the code is microscopically uglier, but we cut our work pretty much in half. But of course, it’s tempting to go further. We check an awful lot of multiples of 3 as well, you know? And of 5? What if we could just skip those too? Turns out there’s a well-known optimization technique known as “wheel factorization” that allows us to do just that.</p>
<p>Here’s a 2*3*5 wheel (well, the three first layers of it, anyway). Note that it starts at 7, which is the first prime we’re <em>not</em> including in this wheel factorization.</p>
<p><img src="/images/ba36f18477b3/wheel-factorization.png" alt="Wheel factorization"></p>
<p>The green “spokes” of the wheel represents sectors where you might find a prime number. The big red areas you don’t even have to check, because they contain only multiples of the first three primes.</p>
<p>Obviously then, the wheel allows us to rule out a great deal of numbers right off the bat. The numbers not filtered out by the wheel are checked in the normal way. According to O’Neill, there are quickly diminishing returns in using large wheels, so we’ll restrain ourselves to a small wheel that takes out the multiples of 2, 3, and 5.</p>
<p>Now how do we implement this wheel in our code? Well, clearly the wheel can be represented as another infinite sequence, with the characteristic that it repeats the same pattern of numbers to skip over and over again. Well gee, that sounds almost like a broken record, doesn’t it? (You’d think I planned these things!)</p>
<p>Say you wanted to create an infinite skip sequence corresponding to the wheel shown above. This code would do nicely:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="kt">var</span> <span class="n">skip</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="m">4</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">6</span> <span class="p">};</span>
<span class="kt">var</span> <span class="n">skipSequence</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BrokenRecord</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="n">skip</span><span class="p">);</span>
</code></pre>
<p>Now we can use the skip sequence to create a sequence of prime candidate numbers. We’ll call it a <strong>WheelSequence</strong> for lack of a better term.</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">WheelSequence</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">_startValue</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">_</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">WheelSequence</span><span class="p">(</span><span class="kt">int</span> <span class="n">startValue</span><span class="p">,</span> 
    <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">skipSequence</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_startValue</span> <span class="p">=</span> <span class="n">startValue</span><span class="p">;</span>
    <span class="n">_</span> <span class="p">=</span> <span class="n">skipSequence</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="n">_startValue</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">wse</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WheelSequenceEnumerator</span><span class="p">(</span><span class="n">_startValue</span><span class="p">,</span> 
                                          <span class="n">_</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">());</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">wse</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="k">yield</span> <span class="k">return</span> <span class="n">wse</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">WheelSequenceEnumerator</span> <span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">_</span><span class="p">;</span>
  <span class="k">private</span> <span class="kt">int</span> <span class="n">_value</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">WheelSequenceEnumerator</span><span class="p">(</span><span class="kt">int</span> <span class="n">startValue</span><span class="p">,</span> 
    <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">skip</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_value</span> <span class="p">=</span> <span class="n">startValue</span><span class="p">;</span>
    <span class="n">_</span> <span class="p">=</span> <span class="n">skip</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">_</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">();</span>
    <span class="n">_value</span> <span class="p">+=</span> <span class="n">_</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">int</span> <span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_value</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Current</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Reset</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Now we can replace our original naive <strong>PrimeEnumerator</strong> with one that uses wheel factorization to greatly reduce the number of candidates considered.</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">WheelPrimeEnumerator</span> <span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">_candidates</span> <span class="p">=</span> 
    <span class="k">new</span> <span class="nf">WheelSequence</span><span class="p">(</span><span class="m">11</span><span class="p">,</span> 
      <span class="k">new</span> <span class="n">BrokenRecord</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span>
        <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="m">4</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">6</span> <span class="p">}</span>
      <span class="p">)</span>
    <span class="p">).</span><span class="n">GetEnumerator</span><span class="p">();</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IPriorityQueue</span><span class="p">&lt;</span><span class="n">NumberEnumerator</span><span class="p">&gt;</span> <span class="n">_pq</span> <span class="p">=</span> 
    <span class="k">new</span> <span class="n">IntervalHeap</span><span class="p">&lt;</span><span class="n">NumberEnumerator</span><span class="p">&gt;();</span>

  <span class="k">public</span> <span class="kt">int</span> <span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_candidates</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">_candidates</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">();</span>
      <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">_candidates</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="n">crossedOut</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(!</span><span class="n">crossedOut</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_pq</span><span class="p">.</span><span class="n">IsEmpty</span> <span class="p">||</span> <span class="n">n</span> <span class="p">&lt;</span> <span class="n">_pq</span><span class="p">.</span><span class="n">FindMin</span><span class="p">().</span><span class="n">Current</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="c1">// There are no pending prime-multiples.</span>
          <span class="c1">// This means n is a prime!</span>
          <span class="n">_pq</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">NumberEnumerator</span><span class="p">(</span><span class="n">n</span><span class="p">*</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
          <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">crossedOut</span> <span class="p">=</span> <span class="n">n</span> <span class="p">==</span> <span class="n">_pq</span><span class="p">.</span><span class="n">FindMin</span><span class="p">().</span><span class="n">Current</span><span class="p">;</span>
        <span class="k">do</span>
        <span class="p">{</span>
          <span class="kt">var</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">_pq</span><span class="p">.</span><span class="n">DeleteMin</span><span class="p">();</span>
          <span class="n">temp</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">();</span>
          <span class="n">_pq</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="p">&gt;</span> <span class="n">_pq</span><span class="p">.</span><span class="n">FindMin</span><span class="p">().</span><span class="n">Current</span><span class="p">)</span> <span class="p">||</span> 
                 <span class="p">(</span><span class="n">crossedOut</span> <span class="p">&amp;&amp;</span> <span class="n">n</span> <span class="p">==</span> <span class="n">_pq</span><span class="p">.</span><span class="n">FindMin</span><span class="p">().</span><span class="n">Current</span><span class="p">));</span>
      <span class="p">}</span>              
    <span class="p">}</span> 
  <span class="p">}</span>

  <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Current</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span> <span class="p">{}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Reset</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>This particular implementation uses a wheel that pre-eliminates multiples of 2, 3, and 5, but obviously you could use any wheel you want. Note that the only difference between this implementation and the <strong>OddPrimeEnumerator</strong> is in the choice of <strong>IEnumerator&lt;int&gt;</strong> for prime number candidates. The rest is unchanged.</p>
<p>Of course, to use this thing, we must first manually yield the primes that we eliminated the multiples of. Like so:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">WheelPrimeSequence</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="m">2</span><span class="p">;</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="m">3</span><span class="p">;</span>
    <span class="k">yield</span> <span class="k">return</span> <span class="m">5</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">e</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WheelPrimeEnumerator</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="k">yield</span> <span class="k">return</span> <span class="n">e</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>That just about wraps it up. I should point out that the current implementation doesn’t <em>really</em> give you an infinite sequence of primes. Unfortunately, the abstraction is all a-leak like a broken faucet since the pesky real world of finite-sized integers causes it to break down at a certain point. In fact, for the current implementation, that point is after the 4.792th prime, which is 46.349. Why? Because then we start a prime-multiple sequence at 46.349*46.349, which won’t fit into the 32-bit integer we’re currently using to store the current value. Hence we get a overflow, the prime-multiple sequence gets a negative number, and it’s all messed up. We really should put an if-statement in there, to return <strong>false</strong> from <strong>MoveNext</strong> if and when we overflow, effectively terminating our not-so-infinite-infinite sequence.</p>
<p>Of course we could use a 64-bit integer instead, but keep in mind that we’re really just buying time - we’re not fixing the underlying problem. C# doesn’t have arbitrary-sized integers, end of story. Nevertheless, 64-bit integers will give you primes larger than 3.000.000.000. I’d say it’s good enough for an academic exercise; or as I like to put it, large enough for all impractical purposes.</p>
<p>Do I certify?</p>
</body></html>