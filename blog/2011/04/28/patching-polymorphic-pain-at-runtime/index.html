<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><link rel="icon" sizes="any" type="image/svg+xml" href="/images/3d4226764423/favfish.svg"><script data-goatcounter="https://einarwh.goatcounter.com/count" async="" src="https://gc.zgo.at/count.js"></script><title>Patching polymorphic pain at runtime | einarwh</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta property="og:title" content="Patching polymorphic pain at runtime"><meta property="og:url" content="https://einarwh.no/blog/2011/04/28/patching-polymorphic-pain-at-runtime/"><link rel="stylesheet" href="/bundles/24d0f8eccbfa/app.css"></head><body><header><div id="blog-header"><span style="display:inline-block"><a href="/">einarwh</a></span><span style="float: right;"><a href="/feed/atom.xml">feed</a></span></div><hr></header><h1>Patching polymorphic pain at runtime</h1>
<p class="blog-post-date">April 28, 2011</p>
<p>In the last post, we saw that data binding in ASP.NET doesn’t support polymorphism. We also saw that we could mitigate the problem by using simple wrapper types. Writing such wrappers by hand won’t kill you, but it is fairly brain-dead. I mentioned that an alternative would be to generate the wrappers at runtime, using reflection. That actually sounds like a bit of fun, so let’s see how it can be done. If nothing else, it’s a nice introductory lesson in using <strong>Reflection.Emit</strong>.</p>
<h2>Comeback of the canines</h2>
<p>As an example, let’s revisit our two four-legged friends and one enemy from the previous post: the <strong>Dog</strong>, the <strong>Chihuahua</strong> and the <strong>Wolf</strong>. They all implement <strong>ICanine</strong>.</p>
<p>The canines have gained a skill since last time, though - they can now indicate whether or not they’ll enjoy a particular kind of food. The code looks like this:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">enum</span> <span class="n">Food</span> <span class="p">{</span> <span class="n">Biscuit</span><span class="p">,</span> <span class="n">Meatballs</span><span class="p">,</span> <span class="n">You</span> <span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">ICanine</span>
<span class="p">{</span>
  <span class="kt">string</span> <span class="n">Bark</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">Eats</span><span class="p">(</span><span class="n">Food</span> <span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Wolf</span> <span class="p">:</span> <span class="n">ICanine</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">virtual</span> <span class="kt">string</span> <span class="n">Bark</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"Aooo!"</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>

   <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Eats</span><span class="p">(</span><span class="n">Food</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span> <span class="p">!=</span> <span class="n">Food</span><span class="p">.</span><span class="n">Biscuit</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Dog</span> <span class="p">:</span> <span class="n">ICanine</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">virtual</span> <span class="kt">string</span> <span class="n">Bark</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"Woof!"</span><span class="p">;</span>  <span class="p">}</span> <span class="p">}</span>

  <span class="k">public</span> <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">Eats</span><span class="p">(</span><span class="n">Food</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span> <span class="p">!=</span> <span class="n">Food</span><span class="p">.</span><span class="n">You</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Chihuahua</span> <span class="p">:</span> <span class="n">Dog</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="n">Bark</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"Arff!"</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>

  <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">Eats</span><span class="p">(</span><span class="n">Food</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span> <span class="p">==</span> <span class="n">Food</span><span class="p">.</span><span class="n">Biscuit</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>What we want to do in our web application is display a grid that shows the canine’s eating preferences as well as its bark. This calls for a combination of auto-generated and custom columns: an automatic one for the <strong>Bark</strong> property, and a custom one for each kind of food.</p>
<p>The <strong>DataGrid</strong> is declared in the .aspx page:</p>
<pre class="codehilite"><code class="language-xml"><span></span><span class="nt">&lt;asp:DataGrid</span>
  <span class="na">ID=</span><span class="s">"_grid"</span>
  <span class="na">runat=</span><span class="s">"server"</span>
  <span class="na">Auto-generateColumns=</span><span class="s">"true"</span>
  <span class="na">Font-Size=</span><span class="s">"X-Large"</span>
  <span class="na">Font-Names=</span><span class="s">"Consolas"</span>
  <span class="na">HeaderStyle-BackColor=</span><span class="s">"LightBlue"</span> <span class="nt">/&gt;</span>
</code></pre>
<p>This gives us a column for the <strong>Bark</strong> out of the box.</p>
<p>In the code-behind, we add a column for each kind of food. We also get a list of canines, which we wrap in something called an <strong>BoxEnumerable&lt;ICanine&gt;</strong> before binding to it.</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">protected</span> <span class="k">void</span> <span class="nf">Page_Load</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GetGridColumns</span><span class="p">().</span><span class="n">ForEach</span><span class="p">(</span><span class="n">f</span> <span class="p">=&gt;</span> <span class="n">_grid</span><span class="p">.</span><span class="n">Columns</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
  <span class="n">_grid</span><span class="p">.</span><span class="n">DataSource</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BoxEnumerable</span><span class="p">&lt;</span><span class="n">ICanine</span><span class="p">&gt;(</span><span class="n">GetCanines</span><span class="p">());</span>
  <span class="n">_grid</span><span class="p">.</span><span class="n">DataBind</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">static</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">DataGridColumn</span><span class="p">&gt;</span> <span class="n">GetGridColumns</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">DataGridColumn</span><span class="p">&gt;</span>
  <span class="p">{</span>
    <span class="k">new</span> <span class="n">TemplateColumn</span>
    <span class="p">{</span>
      <span class="n">HeaderText</span> <span class="p">=</span> <span class="s">"Biscuits?"</span><span class="p">,</span>
      <span class="n">ItemTemplate</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FoodColumnTemplate</span><span class="p">(</span><span class="n">Food</span><span class="p">.</span><span class="n">Biscuit</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="k">new</span> <span class="n">TemplateColumn</span>
    <span class="p">{</span>
      <span class="n">HeaderText</span> <span class="p">=</span> <span class="s">"Meatballs?"</span><span class="p">,</span>
      <span class="n">ItemTemplate</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FoodColumnTemplate</span><span class="p">(</span><span class="n">Food</span><span class="p">.</span><span class="n">Meatballs</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="k">new</span> <span class="n">TemplateColumn</span>
    <span class="p">{</span>
      <span class="n">HeaderText</span> <span class="p">=</span> <span class="s">"You?"</span><span class="p">,</span>
      <span class="n">ItemTemplate</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FoodColumnTemplate</span><span class="p">(</span><span class="n">Food</span><span class="p">.</span><span class="n">You</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ICanine</span><span class="p">&gt;</span> <span class="n">GetCanines</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ICanine</span><span class="p">&gt;</span> <span class="p">{</span><span class="k">new</span> <span class="n">Dog</span><span class="p">(),</span> <span class="k">new</span> <span class="n">Wolf</span><span class="p">(),</span> <span class="k">new</span> <span class="n">Chihuahua</span><span class="p">()</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre>
<p>The food preference columns use an <strong>ItemTemplate</strong> called <strong>FoodColumnTemplate</strong>. It’s a simple example of data binding which goes beyond mere properties, since we’re invoking a method on the data item:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">class</span> <span class="nc">FoodColumnTemplate</span> <span class="p">:</span> <span class="n">ITemplate</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">Food</span> <span class="n">_food</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">FoodColumnTemplate</span><span class="p">(</span><span class="n">Food</span> <span class="n">food</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_food</span> <span class="p">=</span> <span class="n">food</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">InstantiateIn</span><span class="p">(</span><span class="n">Control</span> <span class="n">container</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">label</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Label</span><span class="p">();</span>
    <span class="n">label</span><span class="p">.</span><span class="n">DataBinding</span> <span class="p">+=</span> <span class="n">OnDataBinding</span><span class="p">;</span>
    <span class="n">container</span><span class="p">.</span><span class="n">Controls</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">label</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="k">void</span> <span class="nf">OnDataBinding</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">label</span> <span class="p">=</span> <span class="p">(</span><span class="n">Label</span><span class="p">)</span> <span class="n">sender</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">row</span> <span class="p">=</span> <span class="p">(</span><span class="n">DataGridItem</span><span class="p">)</span> <span class="n">label</span><span class="p">.</span><span class="n">NamingContainer</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">canine</span> <span class="p">=</span> <span class="p">(</span><span class="n">ICanine</span><span class="p">)</span> <span class="n">row</span><span class="p">.</span><span class="n">DataItem</span><span class="p">;</span>
    <span class="n">label</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="n">canine</span><span class="p">.</span><span class="n">Eats</span><span class="p">(</span><span class="n">_food</span><span class="p">)</span> <span class="p">?</span> <span class="s">"Yes"</span> <span class="p">:</span> <span class="s">"No"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>If we run the application, we get the result we wanted:</p>
<p><img src="/images/ce38c85dc1a9/food-table.png" alt="Table of food preferences for canines."></p>
<p>Without the presence of the <strong>BoxEnumerable&lt;ICanine&gt;</strong> above, though, we’d have a runtime exception at our hands. Under the covers, <strong>BoxEnumerable&lt;ICanine&gt;</strong> is producing the necessary wrappers around the actual canines to keep the <strong>DataGrid</strong> happy.</p>
<h2>How it works</h2>
<p>Let’s see how we can do this. Here’s an overview of the different moving parts:</p>
<p><img src="/images/8a325f6a0095/box-overview.png" alt="Overview of boxes"></p>
<p>That’s a fair amount of types, but most of them have trivial implementations. Consider <strong>BoxEnumerable&lt;T&gt;</strong> first:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">BoxEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_</span><span class="p">;</span>

  <span class="k">public</span> <span class="nf">BoxEnumerable</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_</span> <span class="p">=</span> <span class="n">e</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">BoxEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">_</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>As you can see, it’s really the simplest possible wrapper around the original <strong>IEnumerable&lt;T&gt;</strong>, turning it into an <strong>IEnumerable&lt;Box&lt;T&gt;&gt;</strong>. It relies on another wrapper type, <strong>BoxEnumerator&lt;T&gt;</strong>:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">BoxEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">BoxFactory</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_factory</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BoxFactory</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

  <span class="k">public</span> <span class="nf">BoxEnumerator</span><span class="p">(</span><span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_</span> <span class="p">=</span> <span class="n">e</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">_</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">_</span><span class="p">.</span><span class="n">MoveNext</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">void</span> <span class="nf">Reset</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">_</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_factory</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="n">_</span><span class="p">.</span><span class="n">Current</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Current</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>That too is just a minimal wrapper. The only remotely interesting code is in the <strong>Current</strong> property, where a <strong>BoxFactory&lt;T&gt;</strong> is responsible for turning the <strong>T</strong> instance into a <strong>Box&lt;T&gt;</strong> instance. <strong>BoxFactory&lt;T&gt;</strong> looks like this:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">BoxFactory</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_</span> <span class="p">=</span> <span class="n">EmptyBoxFactory</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">CreateEmptyBox</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>

  <span class="k">public</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Get</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">_</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>This is short but a little weird, perhaps. For fun, we’re adding a dash of premature optimization here. We’re using <strong>EmptyBoxFactory</strong> to create an “empty” instance of <strong>Box&lt;T&gt;</strong> (that is, without an instance of <strong>T</strong> inside). The <strong>BoxFactory&lt;T&gt;</strong> holds on to that empty instance for the rest of its lifetime, and uses it to create “populated” boxes. In other words, the initial empty box acts as a <em>prototype</em> for all subsequent boxes. That way, we avoid using reflection more than once to create the boxes. This should make people who fear the performance penalty of reflection a little happier. Let’s see how the prototype creates populated boxes for the factory:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Create</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">box</span> <span class="p">=</span> <span class="p">(</span><span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="n">MemberwiseClone</span><span class="p">();</span>
  <span class="n">box</span><span class="p">.</span><span class="n">_</span> <span class="p">=</span> <span class="n">t</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">box</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
<p>Easy as pie, we’re just cloning and setting the protected <strong>T</strong> field. Doesn’t get much simpler than that.</p>
<p>It’s time to start worrying about the box itself, though. Of course, this is where things get both non-trivial and interesting.</p>
<p>So the goal is to create a type at runtime. The type should be used to wrap each item in an <strong>IEnumerable&lt;T&gt;</strong>, so that the control’s <strong>DataSource</strong> is set to a perfectly homogenous <strong>IEnumerable</strong>. That is, it will only contain instances of the same concrete type. The wrapper type won’t have any intelligence of its own, it will merely delegate to the wrapped instance of <strong>T</strong>.</p>
<p>To support auto-generation of columns, the wrapper type must have the same public properties as <strong>T</strong>. (We won’t consider the option of masking or renaming properties - that’s a use case that goes beyond just fixing what is broken.) In the case of <strong>T</strong> being an interface, a viable option would be for the wrapper type to implement <strong>T</strong>. However, we need the wrapper to work for all kinds of <strong>T</strong>, including when <strong>T</strong> is a base class with one or more non-virtual members. In the general case, therefore, the wrapper must simply mimic the same properties, duck typing-style.</p>
<p>Auto-generation of columns is pretty nifty, and a property-mimicking wrapper is sufficient for that scenario. For more sophisticated data binding scenarios, though, you need to be able to call arbitrary methods on the item we’re binding to. To do so in the general case (where <strong>T</strong> might be a class), we need some way of shedding the wrapper. We can’t simply call the methods on the wrapper itself, since we don’t have access to the name of the dynamically generated wrapper type at compile time. The C# compiler wouldn’t let us (well, we could use <strong>dynamic</strong>, but then we’re giving up static typing). So we’ll be using an <strong>Unwrap</strong> method, giving us access to the bare <strong>T</strong>. (Note that we can’t use a property, since that would show up when auto-generating columns!)</p>
<p>Now how can we call <strong>Unwrap</strong> if the type doesn’t even exist at compile time? Well, we know that there’s a small set of core capabilities that all wrapper types are going to need: the wrapped instance of <strong>T</strong>, and a way of wrapping and unwrapping <strong>T</strong>. So let’s create an abstract base class containing just that:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
  <span class="k">protected</span> <span class="n">T</span> <span class="n">_</span><span class="p">;</span>

  <span class="k">public</span> <span class="n">T</span> <span class="nf">Unwrap</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">public</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Create</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">box</span> <span class="p">=</span> <span class="n">MemberwiseClone</span><span class="p">();</span>
    <span class="n">box</span><span class="p">.</span><span class="n">_</span> <span class="p">=</span> <span class="n">t</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">box</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>That way, we can always cast to <strong>Box&lt;T&gt;</strong>, call <strong>Unwrap</strong>, and we’re good.</p>
<p>Why are we calling it a “box”, by the way? It’s sort of a tip of the hat to academia, of all things. According to this paper on micro patterns, a “box” is “a class which has exactly one, mutable, instance field”. That suits our implementation to a <strong>T</strong> (hah!) so “box” it is.</p>
<p>The concrete box for our example should conceptually look like this:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">BoxedICanine</span> <span class="p">:</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">ICanine</span><span class="p">&gt;,</span> <span class="n">ICanine</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">string</span> <span class="n">Bark</span>
  <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_</span><span class="p">.</span><span class="n">Bark</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Eats</span><span class="p">(</span><span class="n">Food</span> <span class="n">f</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">_</span><span class="p">.</span><span class="n">Eats</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Of course, the boxes we generate at runtime will never actually have a C# manifestation - they will be bytecode only. At this point though, the hand-written example will prove useful as target for our dynamically generated type.</p>
<p>Note that we’re going to try to be a little clever in our implementation. In the case where <strong>T</strong> is an interface (like <strong>ICanine</strong>), we’re going to let the dynamically generated box implement the original interface <strong>T</strong>, in addition to extending <strong>Box&lt;T&gt;</strong>. This will allow us to pretend that the box isn’t even there during data binding. You might recall that we’re casting to <strong>ICanine</strong> rather than calling <strong>Unwrap</strong> in the <strong>FoodColumnTemplate</strong>, even though the data item is our dynamically generated type rather than the original canine. Obviously we won’t be able to pull off that trick when <strong>T</strong> is a class, since C# has single inheritance.</p>
<p>Looking at the bytecode for <strong>BoxedICanine</strong> in ILDASM, ILSpy or Reflector, you should see something like this (assuming you’re doing a release compilation):</p>
<pre class="codehilite"><code><span></span>.class public auto ansi beforefieldinit BoxedICanine
    extends PolyFix.Lib.Box`1&lt;class PolyFix.Lib.ICanine&gt;
    implements PolyFix.Lib.ICanine
{
  .method public hidebysig specialname rtspecialname instance void .ctor() cil managed
  {
    .maxstack 8
    L_0000: ldarg.0
    L_0001: call instance void PolyFix.Lib.Box`1&lt;class PolyFix.Lib.ICanine&gt;::.ctor()
    L_0006: ret
  }

  .method public hidebysig newslot virtual final instance bool Eats(valuetype PolyFix.Lib.Food f) cil managed
  {
    .maxstack 8
    L_0000: ldarg.0
    L_0001: ldfld !0 PolyFix.Lib.Box`1&lt;class PolyFix.Lib.ICanine&gt;::_
    L_0006: ldarg.1
    L_0007: callvirt instance bool PolyFix.Lib.ICanine::Eats(valuetype PolyFix.Lib.Food)
    L_000c: ret
  }

  .method public hidebysig specialname newslot virtual final instance string get_Bark() cil managed
  {
    .maxstack 8
    L_0000: ldarg.0
    L_0001: ldfld !0 PolyFix.Lib.Box`1&lt;class PolyFix.Lib.ICanine&gt;::_
    L_0006: callvirt instance string PolyFix.Lib.ICanine::get_Bark()
    L_000b: ret
  }

  .property instance string Bark
  {
    .get instance string PolyFix.Lib.BoxedICanine::get_Bark()
  }
}
</code></pre>
<p>This, then, is what we’re aiming for. If we can generate this type at runtime, using <strong>ICanine</strong> as input, we’re good.</p>
<h2>IL for beginners</h2>
<p>If you’re new to IL, here’s a simple walk-through of the <strong>get_Bark</strong> method. IL is a stack-based language, meaning it uses a stack to transfer state between operations. In addition, state can be written to and read from local variables.</p>
<p>The <strong>.maxstack 8</strong> instruction tells the runtime that a stack containing a eight elements will be sufficient for this method (in reality, the stack will never be more than a single element deep, so eight is strictly overkill). That’s sort of a preamble to the actual instructions, which come next. The <strong>ldarg.0</strong> instruction loads argument 0 onto the stack, that is, the first parameter of the method. Now that’s confusing, since <strong>get_Bark</strong> seems to have no parameters, right? However, all instance methods receive a reference to <strong>this</strong> as an implicit 0th argument. So <strong>ldarg.0</strong> loads the <strong>this</strong> reference onto the stack. This is necessary to read the <strong>_</strong> instance field, which happens in the <strong>ldfld !0</strong> instruction that follows. The <strong>ldfld !0</strong> pops the <strong>this</strong> reference from the stack, and pushes the reference held by the 0th field (<strong>_</strong>) back on. So now we got an reference to an <strong>ICanine</strong> on there. The following <strong>callvirt</strong> instruction pops the <strong>ICanine</strong> reference from the stack and invokes <strong>get_Bark</strong> on it (passing the reference as the implicit 0th argument, of course). When the method returns, it will have pushed its return value onto the stack. So there will be a reference to a string there. Finally, ret returns from the method, leaving the string reference on the stack as the return value from the method.</p>
<p>If you take a look at the <strong>Eats</strong> method next, you’ll notice it’s practically identical to <strong>get_Bark</strong>. That’s because we’re essentially doing the same thing: delegating directly to the underlying <strong>T</strong> instance referenced by the <strong>_</strong> field.</p>
<p>Now, how can we generate stuff like this on the fly?</p>
<h2>Creating a type at runtime</h2>
<p>As you can see below, a .NET type lives inside a module that lives inside an assembly that lives inside an appdomain.</p>
<p><img src="/images/3ab9e3b0bcfb/appdomain-blue.png" alt="AppDomain"></p>
<p>So before we can start generating the actual type, we need to provide the right environment for the type to live in. We only want to create this environment once, so we’ll do it inside the constructor of our singleton <strong>EmptyBoxFactory</strong>:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">private</span> <span class="k">readonly</span> <span class="n">ModuleBuilder</span> <span class="n">_moduleBuilder</span><span class="p">;</span>

<span class="k">private</span> <span class="nf">EmptyBoxFactory</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">string</span> <span class="n">ns</span> <span class="p">=</span> <span class="s">"PolyFix.Boxes"</span><span class="p">;</span>
  <span class="n">_moduleBuilder</span> <span class="p">=</span> <span class="n">Thread</span><span class="p">.</span><span class="n">GetDomain</span><span class="p">()</span>
    <span class="p">.</span><span class="n">DefineDynamicAssembly</span><span class="p">(</span><span class="k">new</span> <span class="n">AssemblyName</span><span class="p">(</span><span class="n">ns</span><span class="p">),</span> <span class="n">AssemblyBuilderAccess</span><span class="p">.</span><span class="n">Run</span><span class="p">)</span>
    <span class="p">.</span><span class="n">DefineDynamicModule</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p><strong>AssemblyBuilderAccess.Run</strong> indicates that we’re creating a transient assembly - it won’t be persisted to disk. We’re holding on to the module builder, which we’ll use when creating types later on. Assuming that we’ll be using the <strong>BoxEnumerable&lt;T&gt;</strong> in multiple data binding scenarios (for various <strong>T</strong>s), the module will be accumulating types over time.</p>
<p>The public API of <strong>EmptyBoxFactory</strong> is limited to a single method, <strong>CreateEmptyBox</strong>. It uses reflection to create an instance of the appropriate type.</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">CreateEmptyBox</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span><span class="n">Activator</span><span class="p">.</span><span class="n">CreateInstance</span><span class="p">(</span><span class="n">GetBoxType</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;());</span>
<span class="p">}</span>
</code></pre>
<p>Creating the instance is simple enough (albeit slower than newing up objects the conventional way). The real work lies in coming up with the type to instantiate, so we need to move on! <strong>GetBoxType&lt;T&gt;</strong> looks like this:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">private</span> <span class="n">Type</span> <span class="n">GetBoxType</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">t</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
  <span class="kt">string</span> <span class="n">typeName</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">FullName</span> <span class="p">+</span> <span class="s">"Box"</span><span class="p">;</span>
  <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">existingType</span> <span class="k">in</span> <span class="n">_moduleBuilder</span><span class="p">.</span><span class="n">GetTypes</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">existingType</span><span class="p">.</span><span class="n">FullName</span> <span class="p">==</span> <span class="n">typeName</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">existingType</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nf">CreateBoxType</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="k">typeof</span> <span class="p">(</span><span class="n">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;),</span> <span class="n">typeName</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>We’re still treading the waters, though. Specifically, we’re just checking if the module already contains the suitable box type - meaning that we’ve been down this road before. Assuming we haven’t (and we haven’t, have we?), we’ll go on to <strong>CreateBoxType</strong>. Hopefully we’ll see something interesting there.</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="n">Type</span> <span class="nf">CreateBoxType</span><span class="p">(</span><span class="n">Type</span> <span class="n">t</span><span class="p">,</span> <span class="n">Type</span> <span class="n">boxType</span><span class="p">,</span> <span class="kt">string</span> <span class="n">typeName</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">var</span> <span class="n">boxBuilder</span> <span class="p">=</span> <span class="n">_moduleBuilder</span><span class="p">.</span><span class="n">DefineType</span><span class="p">(</span>
    <span class="n">typeName</span><span class="p">,</span> <span class="n">TypeAttributes</span><span class="p">.</span><span class="n">Public</span><span class="p">,</span> <span class="n">boxType</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">IsInterface</span> <span class="p">?</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span><span class="n">t</span><span class="p">}</span> <span class="p">:</span> <span class="k">new</span> <span class="n">Type</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>
  <span class="kt">var</span> <span class="n">f</span> <span class="p">=</span> <span class="n">boxType</span><span class="p">.</span><span class="n">GetField</span><span class="p">(</span><span class="s">"_"</span><span class="p">,</span> <span class="n">BindingFlags</span><span class="p">.</span><span class="n">Instance</span> <span class="p">|</span> <span class="n">BindingFlags</span><span class="p">.</span><span class="n">NonPublic</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">BoxTypeFactory</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">boxBuilder</span><span class="p">,</span> <span class="n">f</span><span class="p">).</span><span class="n">Create</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Oh man, it seems we’re still procrastinating! We haven’t reached the bottom of the rabbit hole just yet. Now we’re preparing for the <strong>BoxTypeFactory</strong> to create the actual type.</p>
<p>Two things worth noting, though. One thing is that if <strong>t</strong> is an interface, then we’ll let our new type implement it as mentioned earlier. This will let us pretend that the box isn’t even there during data binding. The other thing is that we’re obtaining a <strong>FieldInfo</strong> instance to represent the <strong>_</strong> field of <strong>BoxType&lt;T&gt;</strong>, which as you’ll recall holds the instance of <strong>T</strong> that we’ll be delegating all our method calls and property accesses to. Once we have the <strong>FieldInfo</strong>, we can actually forget all about <strong>BoxType&lt;T&gt;</strong>. It’s sort of baked into the <strong>TypeBuilder</strong> as the superclass of the type we’re creating, but apart from that, <strong>BoxTypeFactory</strong> is oblivious to it.</p>
<p>But now! Now there’s nowhere left to hide. Let’s take a deep breath, dive in and reflect:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">class</span> <span class="nc">BoxTypeFactory</span>
<span class="p">{</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">Type</span> <span class="n">_type</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">TypeBuilder</span> <span class="n">_boxBuilder</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">FieldInfo</span> <span class="n">_field</span><span class="p">;</span>
  <span class="k">private</span> <span class="k">readonly</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">MethodBuilder</span><span class="p">&gt;</span> <span class="n">_specials</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">MethodBuilder</span><span class="p">&gt;();</span>

  <span class="k">public</span> <span class="nf">BoxTypeFactory</span><span class="p">(</span><span class="n">Type</span> <span class="n">type</span><span class="p">,</span> <span class="n">TypeBuilder</span> <span class="n">boxBuilder</span><span class="p">,</span> <span class="n">FieldInfo</span> <span class="n">field</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">_type</span> <span class="p">=</span> <span class="n">type</span><span class="p">;</span>
    <span class="n">_boxBuilder</span> <span class="p">=</span> <span class="n">boxBuilder</span><span class="p">;</span>
    <span class="n">_field</span> <span class="p">=</span> <span class="n">field</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="n">Type</span> <span class="nf">Create</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="n">MethodInfo</span> <span class="n">m</span> <span class="k">in</span> <span class="n">_type</span><span class="p">.</span><span class="n">GetMethods</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(!</span><span class="n">IsGetType</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="n">CreateProxyMethod</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="n">PropertyInfo</span> <span class="n">p</span> <span class="k">in</span> <span class="n">_type</span><span class="p">.</span><span class="n">GetProperties</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">ConnectPropertyToAccessors</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_boxBuilder</span><span class="p">.</span><span class="n">CreateType</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">IsGetType</span><span class="p">(</span><span class="n">MethodInfo</span> <span class="n">m</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">Name</span> <span class="p">==</span> <span class="s">"GetType"</span> <span class="p">&amp;&amp;</span> <span class="n">m</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Length</span> <span class="p">==</span> <span class="m">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="k">void</span> <span class="nf">CreateProxyMethod</span><span class="p">(</span><span class="n">MethodInfo</span> <span class="n">m</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">parameters</span> <span class="p">=</span> <span class="n">m</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">();</span>

    <span class="c1">// Create a builder for the current method.</span>
    <span class="kt">var</span> <span class="n">methodBuilder</span> <span class="p">=</span> <span class="n">_boxBuilder</span><span class="p">.</span><span class="n">DefineMethod</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span>
        <span class="n">MethodAttributes</span><span class="p">.</span><span class="n">Public</span> <span class="p">|</span> <span class="n">MethodAttributes</span><span class="p">.</span><span class="n">Virtual</span><span class="p">,</span>
        <span class="n">m</span><span class="p">.</span><span class="n">ReturnType</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">).</span><span class="n">ToArray</span><span class="p">());</span>
    <span class="kt">var</span> <span class="n">gen</span> <span class="p">=</span> <span class="n">methodBuilder</span><span class="p">.</span><span class="n">GetILGenerator</span><span class="p">();</span>
    <span class="c1">// Emit opcodes for the method implementation.</span>
    <span class="c1">// The method should just delegate to the T instance held by the _ field.</span>
    <span class="n">gen</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldarg_0</span><span class="p">);</span> <span class="c1">// Load 'this' reference onto the stack.</span>
    <span class="n">gen</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldfld</span><span class="p">,</span> <span class="n">_field</span><span class="p">);</span> <span class="c1">// Load 'T' reference onto the stack (popping 'this').</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">parameters</span><span class="p">.</span><span class="n">Length</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
      <span class="n">gen</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ldarg</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// Load any method parameters onto the stack.</span>
    <span class="p">}</span>
    <span class="n">gen</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">IsVirtual</span> <span class="p">?</span> <span class="n">OpCodes</span><span class="p">.</span><span class="n">Callvirt</span> <span class="p">:</span> <span class="n">OpCodes</span><span class="p">.</span><span class="n">Call</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span> <span class="c1">// Call the method.</span>
    <span class="n">gen</span><span class="p">.</span><span class="n">Emit</span><span class="p">(</span><span class="n">OpCodes</span><span class="p">.</span><span class="n">Ret</span><span class="p">);</span> <span class="c1">// Return from method.</span>

    <span class="c1">// Keep reference to "special" methods (for wiring up properties later).</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">IsSpecialName</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">_specials</span><span class="p">[</span><span class="n">m</span><span class="p">.</span><span class="n">Name</span><span class="p">]</span> <span class="p">=</span> <span class="n">methodBuilder</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="k">void</span> <span class="nf">ConnectPropertyToAccessors</span><span class="p">(</span><span class="n">PropertyInfo</span> <span class="n">p</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">paramTypes</span> <span class="p">=</span> <span class="n">p</span><span class="p">.</span><span class="n">GetIndexParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span><span class="n">ip</span> <span class="p">=&gt;</span> <span class="n">ip</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">pb</span> <span class="p">=</span> <span class="n">_boxBuilder</span><span class="p">.</span><span class="n">DefineProperty</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">Attributes</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">PropertyType</span><span class="p">,</span> <span class="n">paramTypes</span><span class="p">);</span>
    <span class="n">WireUpIfExists</span><span class="p">(</span><span class="s">"get_"</span> <span class="p">+</span> <span class="n">p</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">pb</span><span class="p">.</span><span class="n">SetGetMethod</span><span class="p">);</span>
    <span class="n">WireUpIfExists</span><span class="p">(</span><span class="s">"set_"</span> <span class="p">+</span> <span class="n">p</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">pb</span><span class="p">.</span><span class="n">SetSetMethod</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="k">void</span> <span class="nf">WireUpIfExists</span><span class="p">(</span><span class="kt">string</span> <span class="n">accessor</span><span class="p">,</span> <span class="n">Action</span><span class="p">&lt;</span><span class="n">MethodBuilder</span><span class="p">&gt;</span> <span class="n">wireUp</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_specials</span><span class="p">.</span><span class="n">ContainsKey</span><span class="p">(</span><span class="n">accessor</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">wireUp</span><span class="p">(</span><span class="n">_specials</span><span class="p">[</span><span class="n">accessor</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Oh. That’s almost anti-climatic - it’s not really hard at all. The <strong>Create</strong> method is super-simple: create proxy methods for any public methods in the type we’re wrapping, wire up any properties to the corresponding getter and/or setter methods, and we’re done! <strong>CreateProxyMethod</strong> seems like it might warrant some explanation; however, all we’re really doing is copying verbatim the IL we looked at in our walkthrough of <strong>get_Bark</strong> earlier. The wiring up of properties is necessary because a property consists of two parts at the IL level, a <strong>.property</strong> thing and a <strong>.method</strong> thing for each accessor. That, too, we saw in the IL of the hand-written class. So there’s really not much to it.</p>
<p>You might note that we’re explicitly <em>not</em> creating a proxy for the <strong>GetType</strong> method, defined on <strong>System.Object</strong>. This applies to the case where the type we’re boxing is a class, not an interface. In general, we shouldn’t proxy <em>any</em> non-virtual methods inherited from <strong>System.Object</strong>, but in practice that’s just <strong>GetType</strong>. So we’re taking the easy way out. (Note that the .NET runtime wouldn’t actually be fooled if we <em>did</em> inject a lying <strong>GetType</strong> implementation - it would still reveal the actual type of the object. Still, it’s better to play by the book.)</p>
<p>We <em>will</em> be providing proxies for virtual methods, though (e.g. <strong>Equals</strong>, <strong>GetHashCode</strong> and <strong>ToString</strong>). This makes the box as invisible as possible.</p>
<h2>Afterthought: Anonymous types</h2>
<p>There’s actually an alternative way of getting around the problem with broken polymorphism in simple scenarios. Rather than hand-writing your own wrapper or generating one at runtime, you can have the C# compiler generate one for you at compile time, using anonymous types. In fact, you can approximate a working solution for our example just by doing this in the code-behind:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">protected</span> <span class="k">void</span> <span class="nf">Page_Load</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">_grid</span><span class="p">.</span><span class="n">DataSource</span> <span class="p">=</span> <span class="n">GetCanines</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span>
    <span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span>
      <span class="n">Biscuit</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">Eats</span><span class="p">(</span><span class="n">Food</span><span class="p">.</span><span class="n">Biscuit</span><span class="p">),</span>
      <span class="n">Meatballs</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">Eats</span><span class="p">(</span><span class="n">Food</span><span class="p">.</span><span class="n">Meatballs</span><span class="p">),</span>
      <span class="n">You</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">Eats</span><span class="p">(</span><span class="n">Food</span><span class="p">.</span><span class="n">You</span><span class="p">),</span>
      <span class="n">c</span><span class="p">.</span><span class="n">Bark</span>
    <span class="p">});</span>
  <span class="n">_grid</span><span class="p">.</span><span class="n">DataBind</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
<p>Note that you don’t add any custom columns in this case, it’s all auto-generated. Running the application, you get this:</p>
<p><img src="/images/baa9a09c3e09/food-table-anon.png" alt="Table of food preferences for canines, with anonymous types."></p>
<p>It’s not exactly the same as before, but it’s pretty close. Unfortunately, the approach isn’t very flexible - it breaks down as soon as you want to display something that’s not just text in the grid. For instance, say you want something like this:</p>
<p><img src="/images/4eb5b31e8528/food-dropdown.png" alt="Table of food with dropdown meny."></p>
<p>Anonymous types won’t help you, but the runtime wrapper will (as will a hand-written one, of course). You just need a suitable <strong>ITemplate</strong>:</p>
<pre class="codehilite"><code class="language-csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">FoodListColumnTemplate</span> <span class="p">:</span> <span class="n">ITemplate</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">void</span> <span class="nf">InstantiateIn</span><span class="p">(</span><span class="n">Control</span> <span class="n">container</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">list</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DropDownList</span><span class="p">();</span>
    <span class="n">list</span><span class="p">.</span><span class="n">DataBinding</span> <span class="p">+=</span> <span class="n">OnDataBinding</span><span class="p">;</span>
    <span class="n">container</span><span class="p">.</span><span class="n">Controls</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="k">void</span> <span class="nf">OnDataBinding</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">list</span> <span class="p">=</span> <span class="p">(</span><span class="n">DropDownList</span><span class="p">)</span> <span class="n">sender</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">row</span> <span class="p">=</span> <span class="p">(</span><span class="n">DataGridItem</span><span class="p">)</span> <span class="n">list</span><span class="p">.</span><span class="n">NamingContainer</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">canine</span> <span class="p">=</span> <span class="p">(</span><span class="n">ICanine</span><span class="p">)</span> <span class="n">row</span><span class="p">.</span><span class="n">DataItem</span><span class="p">;</span>
    <span class="n">Action</span><span class="p">&lt;</span><span class="n">Food</span><span class="p">&gt;</span> <span class="k">add</span> <span class="p">=</span> <span class="n">food</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">canine</span><span class="p">.</span><span class="n">Eats</span><span class="p">(</span><span class="n">food</span><span class="p">))</span> <span class="p">{</span> <span class="n">list</span><span class="p">.</span><span class="n">Items</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">food</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span> <span class="p">}</span> <span class="p">};</span>
    <span class="k">add</span><span class="p">(</span><span class="n">Food</span><span class="p">.</span><span class="n">Biscuit</span><span class="p">);</span>
    <span class="k">add</span><span class="p">(</span><span class="n">Food</span><span class="p">.</span><span class="n">Meatballs</span><span class="p">);</span>
    <span class="k">add</span><span class="p">(</span><span class="n">Food</span><span class="p">.</span><span class="n">You</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h2>So…</h2>
<p>Turns out that generating types at runtime is no big deal. It provides a flexible solution to the data binding problem, without the need for mindless hand-written wrappers.</p>
<p>As usual, let me know if you think there’s something wrong with the approach or the implementation. Also, I’d love to hear it if you have a different solution to the problem.</p>
</body></html>