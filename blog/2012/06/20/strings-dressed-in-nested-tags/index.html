<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><link rel="icon" sizes="any" type="image/svg+xml" href="/images/3d4226764423/favfish.svg"><script data-goatcounter="https://einarwh.goatcounter.com/count" async="" src="https://gc.zgo.at/count.js"></script><script src="/js/0486e9205f01/highlight.min.js"></script><script>hljs.highlightAll();</script><title>Strings dressed in nested tags | einarwh</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta property="og:title" content="Strings dressed in nested tags"><meta property="og:url" content="https://einarwh.no/blog/2012/06/20/strings-dressed-in-nested-tags/"><link rel="stylesheet" href="/bundles/3bb5cc0e0a53/app.css"></head><body><header><div id="blog-header"><span style="display:inline-block"><a href="/">einarwh</a></span><span style="float: right;"><a href="/feed/atom.xml">feed</a></span></div><hr></header><h1>Strings dressed in nested tags</h1>
<p class="blog-post-date">June 20, 2012</p>
<p>If you read the previous blog post, you might wonder if you can wrap a string in nested tags, you know, something like this:</p>
<pre><code class="language-csharp">Func&lt;string, string&gt; nested = 
  s =&gt; s.Tag("td").Colspan("2")
                  .Width("100")
        .Tag("tr")
        .Tag("table").Cellpadding("10")
                     .Border("1");
</code></pre>
<p>And the answer is no. No, you can’t. Well you <em>can</em>, but it’s not going to give you the result you want. For instance, if you apply the transform to the string “Hello”, you’ll get this:</p>
<p><img src="/images/b7967030bd81/bad-tag-nesting.png" alt="Useless attempt at tag nesting."></p>
<p>Which is useless.</p>
<p>The reason is obviously that the <strong>Tag</strong> method calls following the first one will all be channeled in to the same <strong>Tag</strong>. Even though there’s an implicit cast to string, there’s nothing in the code triggering that cast. Of course, you could explicitly call <strong>ToString</strong> on the <strong>Tag</strong>, like so:</p>
<pre><code class="language-csharp">Func&lt;string, string&gt; nested = 
  s =&gt; s.Tag("td").Colspan("2")
                  .Width("100")
                  .ToString()
        .Tag("tr").ToString()
        .Tag("table").Cellpadding("10")
                     .Border("1");
</code></pre>
<p>But that’s admitting defeat, since it breaks the illusion we’re trying to create. Plus it’s ugly.</p>
<p>A better way of working around the problem is to compose simple one-tag transforms, like so:</p>
<pre><code class="language-csharp">Func&lt;string, string&gt; cell =
  s =&gt; s.Tag("td").Colspan("2")
                  .Width("100");

Func&lt;string, string&gt; row =
  s =&gt; s.Tag("tr");

Func&lt;string, string&gt; table = 
  s =&gt; s.Tag("table").Cellpadding("10")
                     .Border("1");

Func&lt;string, string&gt; nested = 
  s =&gt; table(row(cell(s)));
</code></pre>
<p>Which is kind of neat and yields the desired result:</p>
<p><img src="/images/89e548aea691/good-tag-nesting.png" alt="Better tag nesting with composition."></p>
<p>But we can attack the problem more directly. There’s not a whole lot we can do to prevent our <strong>Tag</strong> object from capturing the subsequent method calls to <strong>Tag</strong>. But we <em>are</em> free to respond to those method calls in any ol’ way we like. A trivial change to <strong>TryInvokeMember</strong> will do just nicely:</p>
<pre><code class="language-csharp">public override bool TryInvokeMember(
    InvokeMemberBinder binder,
    object[] args,
    out object result)
{
    string arg = GetValue(args);
    string methodName = binder.Name;

    if (methodName == "Tag" &amp;&amp; arg != null)
    {
        result = ToString().Tag(arg);
    }
    else
    {
        _props[methodName] = arg ?? string.Empty;
        result = this;
    }
    
    return true;
}
</code></pre>
<p>So we just single out calls for a method named <strong>Tag</strong> with a single string parameter. For those method calls, we’re not going to do the regular fluent collection of method names and parameters thing. Instead, we’ll convert the existing <strong>Tag</strong> to a string, and return a brand new <strong>Tag</strong> to wrap <em>that</em> string. And now we can go a-nesting tags as much as we’d like, and still get the result we wanted. Win!</p>
</body></html>