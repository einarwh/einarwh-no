<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><link rel="icon" sizes="any" type="image/svg+xml" href="/images/3d4226764423/favfish.svg"><script data-goatcounter="https://einarwh.goatcounter.com/count" async="" src="https://gc.zgo.at/count.js"></script><script src="/js/0486e9205f01/highlight.min.js"></script><script>hljs.highlightAll();</script><title>Function application in la-la land | einarwh</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta property="og:title" content="Function application in la-la land"><meta property="og:url" content="https://einarwh.no/blog/2017/10/11/function-application-in-la-la-land/"><link rel="stylesheet" href="/bundles/3bb5cc0e0a53/app.css"></head><body><header><div id="blog-header"><span style="display:inline-block"><a href="/">einarwh</a></span><span style="float: right;"><a href="/feed/atom.xml">feed</a></span></div><hr></header><h1>Function application in la-la land</h1>
<p class="blog-post-date">October 11, 2017</p>
<p>Here’s a familiar scenario for a programmer: You have some useful function that you would like to apply to some values. It could be concat that concatinates two strings, or add that adds two integers, or cons which prepends an element to a list, or truncate which cuts off a string at the specified length, or indeed any old function f you come up with which takes a bunch of arguments and produces some result.</p>
<p>Simple, right? But there’s a twist! The values you’d like to apply your function to are all trapped in la-la land! And once you have values in la-la land, it’s not obvious how you’d go about getting them out of there. It really depends on the kind of la-la land your values are in. It’s sort of like being trapped in the afterlife. You might be able to return to the land of the living, but it’s not trivial. Certainly not something you’d want your pure, innocent function to have to deal with!</p>
<p>You might wonder how the values ended up in la-la land in the first place. In many cases, they were born there. They are la-la land natives - it’s the only existence they’ve ever known. It sounds weird, but it’s surprisingly common. Indeed, many programs contain not one but several distinct la-la lands, each with their own peculiar laws and customs! Some familiar la-la lands in the .NET world include <code>Task</code>, <code>Nullable</code> and <code>List</code>.</p>
<p>Since la-la lands are so pervasive in our programs, clearly we need to be able to apply functions to the values that dwell there. Previously we’ve seen that if your la-la land is a <code>Functor</code>, there is a <code>Map</code> function that lets us do that. But there is a problem: <code>Map</code> cannot work with any of the functions I mentioned above. The reason is that they all take more than one argument. <code>Map</code> can transform a single value of type <code>T1</code> inside la-la land to a single value of type <code>T2</code> inside la-la land. What <code>Map</code> does is teleport the <code>T1</code> value out of la-la land, apply your function to obtain a <code>T2</code> value, and teleport that back into la-la land. You can of course map multiple times, but you’ll still involving just one la-la land value at a time. So that’s not going to work.</p>
<p>What alternatives do we have? Well, one idea that springs to mind is partial application. If we had a curried function, we could apply it to the la-la land values one by one, producing intermediate functions until we have the final result. For instance, say we have a curried version of <code>add</code> which looks like this:</p>
<pre><code class="language-csharp">Func&lt;int, Func&lt;int, int&gt;&gt; add = a =&gt; b =&gt; a + b;
</code></pre>
<p>Now we have a single-argument function that returns a single-argument function that returns a value. So we can use it like this:</p>
<pre><code class="language-csharp">Func&lt;int, Func&lt;int, int&gt;&gt; add = a =&gt; b =&gt; a + b;
Func&lt;int, int&gt; incr = add(1);
int four = incr(3);
</code></pre>
<p>Unfortunately, this still won’t work with <code>Map</code>. What would happen if we passed the curried add to <code>Map</code>? We would get an <code>incr</code> function stuck inside of la-la land! And then we’d be stuck too. But what if we replaced <code>Map</code> with something that could work with functions living in la-la land? Something like this:</p>
<pre><code class="language-csharp">Lala&lt;TR&gt; Apply&lt;T, TR&gt;(Lala&lt;Func&lt;T, TR&gt;&gt; f, Lala&lt;T&gt; v);
</code></pre>
<p>What <code>Apply</code> needs to do is teleport both the function and the value out of la-la land, apply the function to the value, and teleport the result back into la-la land.</p>
<p>How would this work with our curried add function? Well, first we’d need to teleport the function itself into la-la land. For this, we need a function, which we’ll call <code>Pure</code>. It looks like this:</p>
<pre><code class="language-csharp">Lala&lt;T&gt; Pure&lt;T&gt;(T val);
</code></pre>
<p>In other words, <code>Pure</code> is a one-way portal to la-la land.</p>
<p>Let’s see how this would work for our curried <code>add</code> function:</p>
<pre><code class="language-csharp">static Lala&lt;int&gt; AddLalaIntegers(Lala&lt;int&gt; a, Lala&lt;int&gt; b)
{
    Func&lt;int, Func&lt;int, int&gt;&gt; add = a =&gt; b =&gt; a + b;
    Lala&lt;Func&lt;int, Func&lt;int, int&gt;&gt;&gt; lalaAdd = Lala.Pure(add);
    Lala&lt;Func&lt;int, int&gt;&gt; lalaPartial = Lala.Apply(lalaAdd, a);
    Lala&lt;int&gt; lalaResult = Lala.Apply(lalaPartial, b);
    return lalaResult;
}
</code></pre>
<p>Success! Who would have thought?</p>
<p>Well, someone, obviously. It turns out that la-la lands that support <code>Pure</code> and <code>Apply</code> are known as <code>Applicative</code>.</p>
<p>But there are still questions worth asking, such as: How do we implement these functions? Like <code>Map</code>, <code>Pure</code> and <code>Apply</code> must obey the laws of the particular la-la land they work with. We’re going to look at two examples in C#.</p>
<p>First, consider the la-la land known as <code>Task&lt;T&gt;</code>.</p>
<pre><code class="language-csharp">public static class TaskApplicative
{
    public static Task&lt;T&gt; Pure(T val)
    {
        return Task.FromResult(val);
    }

    public static async Task&lt;TR&gt; Apply&lt;T, TR&gt;(
        this Task&lt;Func&lt;T, TR&gt; funTask,
        Task&lt;T&gt; valTask)
    {
        var fun = await funTask;
        var val = await valTask;
        return fun(val);
    }
}
</code></pre>
<p>Awaiting the tasks bring them out of <code>Task</code>-land, and the return value is automatically transported back by the async machinery.</p>
<p>Second, imagine a type called <code>Mayhaps&lt;T&gt;</code>. <code>Mayhaps</code> is like <code>Nullable</code>, but it works on any type <code>T</code>. Why is this important? Because delegates are reference types, which means they can’t be put inside a <code>Nullable</code>. In other words, functions are not allowed into the la-la land that is <code>Nullable</code>. So <code>Mayhaps</code> it is.</p>
<p><code>Mayhaps</code> has two possible values, <code>Indeed</code> and <code>Sorry</code>. <code>Indeed</code> holds a value, <code>Sorry</code> does not. That’s really all you need to know about <code>Mayhaps</code>. (For implementation details, look <a href="https://gist.github.com/einarwh/0df548e1496d561242ab659d2b3841af">here</a>.)</p>
<p>Here are <code>Pure</code> and <code>Apply</code> for <code>Mayhaps</code>:</p>
<pre><code class="language-csharp">public static class MayhapsApplicative
{
    public static Mayhaps&lt;TR&gt; Pure&lt;TR&gt;(TR v)
    {
        return Mayhaps&lt;TR&gt;.Indeed(v);
    }

    public static Mayhaps&lt;TR&gt; Apply&lt;T, TR&gt;(
        this Mayhaps&lt;Func&lt;T, TR&gt;&gt; mayhapsFunction,
        Mayhaps&lt;T&gt; mayhapsValue)
    {
        if (mayhapsFunction.HasValue &amp;&amp; mayhapsValue.HasValue)
        {
            var fun = mayhapsFunction.Value;
            var val = mayhapsValue.Value;
            return Mayhaps&lt;TR&gt;.Indeed(fun(val));
        }
        else
        {
            return Mayhaps&lt;TR&gt;.Sorry;
        }
    }
}
</code></pre>
<p>The semantics of <code>Mayhaps</code> is to propagate <code>Sorry</code> - you can only get a new <code>Indeed</code> if you have both a function and a value.</p>
<p>And of course the nice thing now is that we can separate our logic from the idiosyncracies of each la-la land! Which is pretty great.</p>
<p>But I’ll admit that we’re currently in a situation where calling a function is a little bit involved and awkward. It’s involved because there’s quite a bit of boilerplate, and it’s awkward because working with curried functions and partial application isn’t necessarily the bread and butter of C# programming. So let’s write some helper functions to alleviate some of that pain.</p>
<p>We can start by writing functions to curry <code>Func</code>s, which should reduce the awkward. There are quite a few of them; here’s an example that curries a <code>Func</code> with four input parameters:</p>
<pre><code class="language-csharp">public static Func&lt;T1, Func&lt;T2, Func&lt;T3, Func&lt;T4, TR&gt;&gt;&gt;&gt; Curry&lt;T1, T2, T3, T4, TR&gt;(
    this Func&lt;T1, T2, T3, T4, TR&gt; f)
{
    return a =&gt; b =&gt; c =&gt; d =&gt; f(a, b, c, d);
}
</code></pre>
<p>We can use it like this:</p>
<pre><code class="language-csharp">Func&lt;int, int, int, int, int&gt; sirplusalot =
    (a, b, c, d) =&gt; a + b + c + d;
Func&lt;int, Func&lt;int, Func&lt;int, Func&lt;int, int&gt;&gt;&gt;&gt; =
    sirplusalot.Curry();
</code></pre>
<p>A little less awkward. What about involved? We’ll define some helper functions to reduce the boilerplate. The idea is to use a function <code>Lift</code> to handle pretty much everything for us. Here is one that can be used with <code>sirplusalot</code>:</p>
<pre><code class="language-csharp">public static Lala&lt;TR&gt; Lift&lt;T1, T2, T3, T4, TR&gt;(
    this Func&lt;T1, T2, T3, T4, TR&gt; f,
    Lala&lt;T1&gt; v1,
    Lala&lt;T2&gt; v2,
    Lala&lt;T3&gt; v3,
    Lala&lt;T4&gt; v4)
{
    return Pure(f.Curry()).Apply(v1).Apply(v2).Apply(v3).Apply(v4);
}
</code></pre>
<p>Note that all <code>Lift</code> functions will have the same structure, regardless of which la-la land they operate in. Only the implementations of <code>Pure</code> and <code>Apply</code> will vary.</p>
<p>And now we can implement functions that look like this:</p>
<pre><code class="language-csharp">private async static Task&lt;int&gt; Plus(
    Task&lt;int&gt; ta,
    Task&lt;int&gt; tb,
    Task&lt;int&gt; tc,
    Task&lt;int&gt; td)
{
    Func&lt;int, int, int, int, int&gt; sirplusalot =
        (a, b, c, d) =&gt; a + b + c + d;
    return await sirplusalot.Lift(ta, tb, tc, td);
}

private static Mayhaps&lt;int&gt; Plus(
    Mayhaps&lt;int&gt; ma,
    Mayhaps&lt;int&gt; mb,
    Mayhaps&lt;int&gt; mc,
    Mayhaps&lt;int&gt; md)
{
    Func&lt;int, int, int, int, int&gt; sirplusalot =
        (a, b, c, d) =&gt; a + b + c + d;
    return sirplusalot.Lift(ma, mb, mc, md);
}
</code></pre>
<p>Which is quite nice? Yes?</p>
</body></html>